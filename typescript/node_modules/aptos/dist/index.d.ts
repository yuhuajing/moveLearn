import nacl from 'tweetnacl';
import EventEmitter from 'eventemitter3';

declare type Seq<T> = T[];
declare type Uint8 = number;
declare type Uint16 = number;
declare type Uint32 = number;
declare type Uint64 = bigint;
declare type Uint128 = bigint;
declare type Uint256 = bigint;
declare type AnyNumber = bigint | number;
declare type Bytes = Uint8Array;

declare class Serializer {
    private buffer;
    private offset;
    constructor();
    private ensureBufferWillHandleSize;
    protected serialize(values: Bytes): void;
    private serializeWithFunction;
    /**
     * Serializes a string. UTF8 string is supported. Serializes the string's bytes length "l" first,
     * and then serializes "l" bytes of the string content.
     *
     * BCS layout for "string": string_length | string_content. string_length is the bytes length of
     * the string that is uleb128 encoded. string_length is a u32 integer.
     *
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeStr("çå∞≠¢õß∂ƒ∫");
     * assert(serializer.getBytes() === new Uint8Array([24, 0xc3, 0xa7, 0xc3, 0xa5, 0xe2, 0x88, 0x9e,
     * 0xe2, 0x89, 0xa0, 0xc2, 0xa2, 0xc3, 0xb5, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xc6, 0x92, 0xe2, 0x88, 0xab]));
     * ```
     */
    serializeStr(value: string): void;
    /**
     * Serializes an array of bytes.
     *
     * BCS layout for "bytes": bytes_length | bytes. bytes_length is the length of the bytes array that is
     * uleb128 encoded. bytes_length is a u32 integer.
     */
    serializeBytes(value: Bytes): void;
    /**
     * Serializes an array of bytes with known length. Therefore length doesn't need to be
     * serialized to help deserialization.  When deserializing, the number of
     * bytes to deserialize needs to be passed in.
     */
    serializeFixedBytes(value: Bytes): void;
    /**
     * Serializes a boolean value.
     *
     * BCS layout for "boolean": One byte. "0x01" for True and "0x00" for False.
     */
    serializeBool(value: boolean): void;
    /**
     * Serializes a uint8 number.
     *
     * BCS layout for "uint8": One byte. Binary format in little-endian representation.
     */
    serializeU8(value: Uint8): void;
    /**
     * Serializes a uint16 number.
     *
     * BCS layout for "uint16": Two bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeU16(4660);
     * assert(serializer.getBytes() === new Uint8Array([0x34, 0x12]));
     * ```
     */
    serializeU16(value: Uint16): void;
    /**
     * Serializes a uint32 number.
     *
     * BCS layout for "uint32": Four bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeU32(305419896);
     * assert(serializer.getBytes() === new Uint8Array([0x78, 0x56, 0x34, 0x12]));
     * ```
     */
    serializeU32(value: Uint32): void;
    /**
     * Serializes a uint64 number.
     *
     * BCS layout for "uint64": Eight bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeU64(1311768467750121216);
     * assert(serializer.getBytes() === new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));
     * ```
     */
    serializeU64(value: AnyNumber): void;
    /**
     * Serializes a uint128 number.
     *
     * BCS layout for "uint128": Sixteen bytes. Binary format in little-endian representation.
     */
    serializeU128(value: AnyNumber): void;
    /**
     * Serializes a uint256 number.
     *
     * BCS layout for "uint256": Sixteen bytes. Binary format in little-endian representation.
     */
    serializeU256(value: AnyNumber): void;
    /**
     * Serializes a uint32 number with uleb128.
     *
     * BCS use uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values
     */
    serializeU32AsUleb128(val: Uint32): void;
    /**
     * Returns the buffered bytes
     */
    getBytes(): Bytes;
}

declare class Deserializer {
    private buffer;
    private offset;
    constructor(data: Bytes);
    private read;
    /**
     * Deserializes a string. UTF8 string is supported. Reads the string's bytes length "l" first,
     * and then reads "l" bytes of content. Decodes the byte array into a string.
     *
     * BCS layout for "string": string_length | string_content. string_length is the bytes length of
     * the string that is uleb128 encoded. string_length is a u32 integer.
     *
     * @example
     * ```ts
     * const deserializer = new Deserializer(new Uint8Array([24, 0xc3, 0xa7, 0xc3, 0xa5, 0xe2, 0x88, 0x9e,
     * 0xe2, 0x89, 0xa0, 0xc2, 0xa2, 0xc3, 0xb5, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xc6, 0x92, 0xe2, 0x88, 0xab]));
     * assert(deserializer.deserializeStr() === "çå∞≠¢õß∂ƒ∫");
     * ```
     */
    deserializeStr(): string;
    /**
     * Deserializes an array of bytes.
     *
     * BCS layout for "bytes": bytes_length | bytes. bytes_length is the length of the bytes array that is
     * uleb128 encoded. bytes_length is a u32 integer.
     */
    deserializeBytes(): Bytes;
    /**
     * Deserializes an array of bytes. The number of bytes to read is already known.
     *
     */
    deserializeFixedBytes(len: number): Bytes;
    /**
     * Deserializes a boolean value.
     *
     * BCS layout for "boolean": One byte. "0x01" for True and "0x00" for False.
     */
    deserializeBool(): boolean;
    /**
     * Deserializes a uint8 number.
     *
     * BCS layout for "uint8": One byte. Binary format in little-endian representation.
     */
    deserializeU8(): Uint8;
    /**
     * Deserializes a uint16 number.
     *
     * BCS layout for "uint16": Two bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const deserializer = new Deserializer(new Uint8Array([0x34, 0x12]));
     * assert(deserializer.deserializeU16() === 4660);
     * ```
     */
    deserializeU16(): Uint16;
    /**
     * Deserializes a uint32 number.
     *
     * BCS layout for "uint32": Four bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const deserializer = new Deserializer(new Uint8Array([0x78, 0x56, 0x34, 0x12]));
     * assert(deserializer.deserializeU32() === 305419896);
     * ```
     */
    deserializeU32(): Uint32;
    /**
     * Deserializes a uint64 number.
     *
     * BCS layout for "uint64": Eight bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const deserializer = new Deserializer(new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));
     * assert(deserializer.deserializeU64() === 1311768467750121216);
     * ```
     */
    deserializeU64(): Uint64;
    /**
     * Deserializes a uint128 number.
     *
     * BCS layout for "uint128": Sixteen bytes. Binary format in little-endian representation.
     */
    deserializeU128(): Uint128;
    /**
     * Deserializes a uint256 number.
     *
     * BCS layout for "uint256": Thirty-two bytes. Binary format in little-endian representation.
     */
    deserializeU256(): Uint256;
    /**
     * Deserializes a uleb128 encoded uint32 number.
     *
     * BCS use uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values
     */
    deserializeUleb128AsU32(): Uint32;
}

interface Serializable {
    serialize(serializer: Serializer): void;
}
/**
 * Serializes a vector values that are "Serializable".
 */
declare function serializeVector<T extends Serializable>(value: Seq<T>, serializer: Serializer): void;
/**
 * Serializes a vector with specified item serialization function.
 * Very dynamic function and bypasses static typechecking.
 */
declare function serializeVectorWithFunc(value: any[], func: string): Bytes;
/**
 * Deserializes a vector of values.
 */
declare function deserializeVector(deserializer: Deserializer, cls: any): any[];
declare function bcsToBytes<T extends Serializable>(value: T): Bytes;
declare function bcsSerializeUint64(value: AnyNumber): Bytes;
declare function bcsSerializeU8(value: Uint8): Bytes;
declare function bcsSerializeU16(value: Uint16): Bytes;
declare function bcsSerializeU32(value: Uint32): Bytes;
declare function bcsSerializeU128(value: AnyNumber): Bytes;
declare function bcsSerializeU256(value: AnyNumber): Bytes;
declare function bcsSerializeBool(value: boolean): Bytes;
declare function bcsSerializeStr(value: string): Bytes;
declare function bcsSerializeBytes(value: Bytes): Bytes;
declare function bcsSerializeFixedBytes(value: Bytes): Bytes;

type index$2_Seq<T> = Seq<T>;
type index$2_Uint8 = Uint8;
type index$2_Uint16 = Uint16;
type index$2_Uint32 = Uint32;
type index$2_Uint64 = Uint64;
type index$2_Uint128 = Uint128;
type index$2_Uint256 = Uint256;
type index$2_AnyNumber = AnyNumber;
type index$2_Bytes = Bytes;
type index$2_Serializer = Serializer;
declare const index$2_Serializer: typeof Serializer;
type index$2_Deserializer = Deserializer;
declare const index$2_Deserializer: typeof Deserializer;
declare const index$2_serializeVector: typeof serializeVector;
declare const index$2_serializeVectorWithFunc: typeof serializeVectorWithFunc;
declare const index$2_deserializeVector: typeof deserializeVector;
declare const index$2_bcsToBytes: typeof bcsToBytes;
declare const index$2_bcsSerializeUint64: typeof bcsSerializeUint64;
declare const index$2_bcsSerializeU8: typeof bcsSerializeU8;
declare const index$2_bcsSerializeU16: typeof bcsSerializeU16;
declare const index$2_bcsSerializeU32: typeof bcsSerializeU32;
declare const index$2_bcsSerializeU128: typeof bcsSerializeU128;
declare const index$2_bcsSerializeU256: typeof bcsSerializeU256;
declare const index$2_bcsSerializeBool: typeof bcsSerializeBool;
declare const index$2_bcsSerializeStr: typeof bcsSerializeStr;
declare const index$2_bcsSerializeBytes: typeof bcsSerializeBytes;
declare const index$2_bcsSerializeFixedBytes: typeof bcsSerializeFixedBytes;
declare namespace index$2 {
  export {
    index$2_Seq as Seq,
    index$2_Uint8 as Uint8,
    index$2_Uint16 as Uint16,
    index$2_Uint32 as Uint32,
    index$2_Uint64 as Uint64,
    index$2_Uint128 as Uint128,
    index$2_Uint256 as Uint256,
    index$2_AnyNumber as AnyNumber,
    index$2_Bytes as Bytes,
    index$2_Serializer as Serializer,
    index$2_Deserializer as Deserializer,
    index$2_serializeVector as serializeVector,
    index$2_serializeVectorWithFunc as serializeVectorWithFunc,
    index$2_deserializeVector as deserializeVector,
    index$2_bcsToBytes as bcsToBytes,
    index$2_bcsSerializeUint64 as bcsSerializeUint64,
    index$2_bcsSerializeU8 as bcsSerializeU8,
    index$2_bcsSerializeU16 as bcsSerializeU16,
    index$2_bcsSerializeU32 as bcsSerializeU32,
    index$2_bcsSerializeU128 as bcsSerializeU128,
    index$2_bcsSerializeU256 as bcsSerializeU256,
    index$2_bcsSerializeBool as bcsSerializeBool,
    index$2_bcsSerializeStr as bcsSerializeStr,
    index$2_bcsSerializeBytes as bcsSerializeBytes,
    index$2_bcsSerializeFixedBytes as bcsSerializeFixedBytes,
  };
}

/**
 * A configuration object we can pass with the request to the server.
 *
 * @param TOKEN - an auth token to send with the request
 * @param HEADERS - extra headers we want to send with the request
 * @param WITH_CREDENTIALS - whether to carry cookies. By default, it is set to true and cookies will be sent
 */
declare type ClientConfig = {
    TOKEN?: string;
    HEADERS?: Record<string, string | number | boolean>;
    WITH_CREDENTIALS?: boolean;
};
/**
 * The API request type
 *
 * @param url - the url to make the request to, i.e https://fullnode.aptoslabs.devnet.com/v1
 * @param method - the request method "GET" | "POST"
 * @param endpoint (optional) - the endpoint to make the request to, i.e transactions
 * @param body (optional) - the body of the request
 * @param contentType (optional) - the content type to set the `content-type` header to,
 * by default is set to `application/json`
 * @param params (optional) - query params to add to the request
 * @param originMethod (optional) - the local method the request came from
 * @param overrides (optional) - a `ClientConfig` object type to override request data
 */
declare type AptosRequest = {
    url: string;
    method: "GET" | "POST";
    endpoint?: string;
    body?: any;
    contentType?: string;
    params?: Record<string, string | AnyNumber | boolean | undefined>;
    originMethod?: string;
    overrides?: ClientConfig;
};
/**
 * The API response type
 *
 * @param status - the response status. i.e 200
 * @param statusText - the response message
 * @param data the response data
 * @param url the url the request was made to
 * @param headers the response headers
 * @param config (optional) - the request object
 * @param request (optional) - the request object
 */
interface AptosResponse<Req, Res> {
    status: number;
    statusText: string;
    data: Res;
    url: string;
    headers: any;
    config?: any;
    request?: Req;
}
/**
 * The type returned from an API error
 *
 * @param name - the error name "AptosApiError"
 * @param url the url the request was made to
 * @param status - the response status. i.e 400
 * @param statusText - the response message
 * @param data the response data
 * @param request - the AptosRequest
 */
declare class AptosApiError extends Error {
    readonly url: string;
    readonly status: number;
    readonly statusText: string;
    readonly data: any;
    readonly request: AptosRequest;
    constructor(request: AptosRequest, response: AptosResponse<any, any>, message: string);
}

/**
 * The main function to use when doing an API request.
 *
 * @param options AptosRequest
 * @returns the response or AptosApiError
 */
declare function aptosRequest<Req, Res>(options: AptosRequest): Promise<AptosResponse<Req, Res>>;

declare type GetRequestOptions = Omit<AptosRequest, "body" | "method">;
/**
 * Main function to do a Get request
 *
 * @param options GetRequestOptions
 * @returns
 */
declare function get<Req, Res>(options: GetRequestOptions): Promise<AptosResponse<Req, Res>>;

declare type PostRequestOptions = Omit<AptosRequest, "method">;
/**
 * Main function to do a Post request
 *
 * @param options PostRequestOptions
 * @returns
 */
declare function post<Req, Res>(options: PostRequestOptions): Promise<AptosResponse<Req, Res>>;

declare enum Network {
    MAINNET = "mainnet",
    TESTNET = "testnet",
    DEVNET = "devnet"
}
interface CustomEndpoints {
    fullnodeUrl: string;
    indexerUrl?: string;
}

/**
 * All bytes (Vec<u8>) data is represented as hex-encoded string prefixed with `0x` and fulfilled with
 * two hex digits per byte.
 *
 * Unlike the `Address` type, HexEncodedBytes will not trim any zeros.
 *
 */
declare type HexEncodedBytes = string;

/**
 * A string containing a 64-bit unsigned integer.
 *
 * We represent u64 values as a string to ensure compatibility with languages such
 * as JavaScript that do not parse u64s in JSON natively.
 *
 */
declare type U64$1 = string;

/**
 * Account data
 *
 * A simplified version of the onchain Account resource
 */
declare type AccountData = {
    sequence_number: U64$1;
    authentication_key: HexEncodedBytes;
};

/**
 * A single Ed25519 signature
 */
declare type Ed25519Signature$1 = {
    public_key: HexEncodedBytes;
    signature: HexEncodedBytes;
};

declare type AccountSignature_Ed25519Signature = ({
    type: string;
} & Ed25519Signature$1);

/**
 * A Ed25519 multi-sig signature
 *
 * This allows k-of-n signing for a transaction
 */
declare type MultiEd25519Signature$1 = {
    /**
     * The public keys for the Ed25519 signature
     */
    public_keys: Array<HexEncodedBytes>;
    /**
     * Signature associated with the public keys in the same order
     */
    signatures: Array<HexEncodedBytes>;
    /**
     * The number of signatures required for a successful transaction
     */
    threshold: number;
    bitmap: HexEncodedBytes;
};

declare type AccountSignature_MultiEd25519Signature = ({
    type: string;
} & MultiEd25519Signature$1);

/**
 * Account signature scheme
 *
 * The account signature scheme allows you to have two types of accounts:
 *
 * 1. A single Ed25519 key account, one private key
 * 2. A k-of-n multi-Ed25519 key account, multiple private keys, such that k-of-n must sign a transaction.
 */
declare type AccountSignature = (AccountSignature_Ed25519Signature | AccountSignature_MultiEd25519Signature);

/**
 * A hex encoded 32 byte Aptos account address.
 *
 * This is represented in a string as a 64 character hex string, sometimes
 * shortened by stripping leading 0s, and adding a 0x.
 *
 * For example, address 0x0000000000000000000000000000000000000000000000000000000000000001 is represented as 0x1.
 *
 */
declare type Address = string;

/**
 * These codes provide more granular error information beyond just the HTTP
 * status code of the response.
 */
declare enum AptosErrorCode {
    ACCOUNT_NOT_FOUND = "account_not_found",
    RESOURCE_NOT_FOUND = "resource_not_found",
    MODULE_NOT_FOUND = "module_not_found",
    STRUCT_FIELD_NOT_FOUND = "struct_field_not_found",
    VERSION_NOT_FOUND = "version_not_found",
    TRANSACTION_NOT_FOUND = "transaction_not_found",
    TABLE_ITEM_NOT_FOUND = "table_item_not_found",
    BLOCK_NOT_FOUND = "block_not_found",
    STATE_VALUE_NOT_FOUND = "state_value_not_found",
    VERSION_PRUNED = "version_pruned",
    BLOCK_PRUNED = "block_pruned",
    INVALID_INPUT = "invalid_input",
    INVALID_TRANSACTION_UPDATE = "invalid_transaction_update",
    SEQUENCE_NUMBER_TOO_OLD = "sequence_number_too_old",
    VM_ERROR = "vm_error",
    HEALTH_CHECK_FAILED = "health_check_failed",
    MEMPOOL_IS_FULL = "mempool_is_full",
    INTERNAL_ERROR = "internal_error",
    WEB_FRAMEWORK_ERROR = "web_framework_error",
    BCS_NOT_SUPPORTED = "bcs_not_supported",
    API_DISABLED = "api_disabled"
}

/**
 * This is the generic struct we use for all API errors, it contains a string
 * message and an Aptos API specific error code.
 */
declare type AptosError = {
    /**
     * A message describing the error
     */
    message: string;
    error_code: AptosErrorCode;
    /**
     * A code providing VM error details when submitting transactions to the VM
     */
    vm_error_code?: number;
};

declare type HashValue = string;

declare type EventGuid = {
    creation_number: U64$1;
    account_address: Address;
};

/**
 * String representation of an on-chain Move type tag that is exposed in transaction payload.
 * Values:
 * - bool
 * - u8
 * - u16
 * - u32
 * - u64
 * - u128
 * - u256
 * - address
 * - signer
 * - vector: `vector<{non-reference MoveTypeId}>`
 * - struct: `{address}::{module_name}::{struct_name}::<{generic types}>`
 *
 * Vector type value examples:
 * - `vector<u8>`
 * - `vector<vector<u64>>`
 * - `vector<0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>>`
 *
 * Struct type value examples:
 * - `0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>
 * - `0x1::account::Account`
 *
 * Note:
 * 1. Empty chars should be ignored when comparing 2 struct tag ids.
 * 2. When used in an URL path, should be encoded by url-encoding (AKA percent-encoding).
 *
 */
declare type MoveType = string;

/**
 * An event from a transaction
 */
declare type Event = {
    guid: EventGuid;
    sequence_number: U64$1;
    type: MoveType;
    /**
     * The JSON representation of the event
     */
    data: any;
};

/**
 * Move module id is a string representation of Move module.
 *
 * Format: `{address}::{module name}`
 *
 * `address` should be hex-encoded 32 byte account address that is prefixed with `0x`.
 *
 * Module name is case-sensitive.
 *
 */
declare type MoveModuleId = string;

/**
 * Delete a module
 */
declare type DeleteModule = {
    address: Address;
    /**
     * State key hash
     */
    state_key_hash: string;
    module: MoveModuleId;
};

declare type WriteSetChange_DeleteModule = ({
    type: string;
} & DeleteModule);

/**
 * String representation of a MoveStructTag (on-chain Move struct type). This exists so you
 * can specify MoveStructTags as path / query parameters, e.g. for get_events_by_event_handle.
 *
 * It is a combination of:
 * 1. `move_module_address`, `module_name` and `struct_name`, all joined by `::`
 * 2. `struct generic type parameters` joined by `, `
 *
 * Examples:
 * * `0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>`
 * * `0x1::account::Account`
 *
 * Note:
 * 1. Empty chars should be ignored when comparing 2 struct tag ids.
 * 2. When used in an URL path, should be encoded by url-encoding (AKA percent-encoding).
 *
 * See [doc](https://aptos.dev/concepts/accounts) for more details.
 *
 */
declare type MoveStructTag = string;

/**
 * Delete a resource
 */
declare type DeleteResource = {
    address: Address;
    /**
     * State key hash
     */
    state_key_hash: string;
    resource: MoveStructTag;
};

declare type WriteSetChange_DeleteResource = ({
    type: string;
} & DeleteResource);

/**
 * Deleted table data
 */
declare type DeletedTableData = {
    /**
     * Deleted key
     */
    key: any;
    /**
     * Deleted key type
     */
    key_type: string;
};

/**
 * Delete a table item
 */
declare type DeleteTableItem = {
    state_key_hash: string;
    handle: HexEncodedBytes;
    key: HexEncodedBytes;
    data?: DeletedTableData;
};

declare type WriteSetChange_DeleteTableItem = ({
    type: string;
} & DeleteTableItem);

declare type IdentifierWrapper = string;

declare type MoveAbility = string;

/**
 * Move function generic type param
 */
declare type MoveFunctionGenericTypeParam = {
    /**
     * Move abilities tied to the generic type param and associated with the function that uses it
     */
    constraints: Array<MoveAbility>;
};

/**
 * Move function visibility
 */
declare enum MoveFunctionVisibility {
    PRIVATE = "private",
    PUBLIC = "public",
    FRIEND = "friend"
}

/**
 * Move function
 */
declare type MoveFunction = {
    name: IdentifierWrapper;
    visibility: MoveFunctionVisibility;
    /**
     * Whether the function can be called as an entry function directly in a transaction
     */
    is_entry: boolean;
    /**
     * Whether the function is a view function or not
     */
    is_view: boolean;
    /**
     * Generic type params associated with the Move function
     */
    generic_type_params: Array<MoveFunctionGenericTypeParam>;
    /**
     * Parameters associated with the move function
     */
    params: Array<MoveType>;
    /**
     * Return type of the function
     */
    return: Array<MoveType>;
};

/**
 * Move struct field
 */
declare type MoveStructField = {
    name: IdentifierWrapper;
    type: MoveType;
};

/**
 * Move generic type param
 */
declare type MoveStructGenericTypeParam = {
    /**
     * Move abilities tied to the generic type param and associated with the type that uses it
     */
    constraints: Array<MoveAbility>;
};

/**
 * A move struct
 */
declare type MoveStruct = {
    name: IdentifierWrapper;
    /**
     * Whether the struct is a native struct of Move
     */
    is_native: boolean;
    /**
     * Abilities associated with the struct
     */
    abilities: Array<MoveAbility>;
    /**
     * Generic types associated with the struct
     */
    generic_type_params: Array<MoveStructGenericTypeParam>;
    /**
     * Fields associated with the struct
     */
    fields: Array<MoveStructField>;
};

/**
 * A Move module
 */
declare type MoveModule = {
    address: Address;
    name: IdentifierWrapper;
    /**
     * Friends of the module
     */
    friends: Array<MoveModuleId>;
    /**
     * Public functions of the module
     */
    exposed_functions: Array<MoveFunction>;
    /**
     * Structs of the module
     */
    structs: Array<MoveStruct>;
};

/**
 * Move module bytecode along with it's ABI
 */
declare type MoveModuleBytecode = {
    bytecode: HexEncodedBytes;
    abi?: MoveModule;
};

/**
 * Write a new module or update an existing one
 */
declare type WriteModule = {
    address: Address;
    /**
     * State key hash
     */
    state_key_hash: string;
    data: MoveModuleBytecode;
};

declare type WriteSetChange_WriteModule = ({
    type: string;
} & WriteModule);

/**
 * This is a JSON representation of some data within an account resource. More specifically,
 * it is a map of strings to arbitrary JSON values / objects, where the keys are top level
 * fields within the given resource.
 *
 * To clarify, you might query for 0x1::account::Account and see the example data.
 *
 * Move `bool` type value is serialized into `boolean`.
 *
 * Move `u8`, `u16` and `u32` type value is serialized into `integer`.
 *
 * Move `u64`, `u128` and `u256` type value is serialized into `string`.
 *
 * Move `address` type value (32 byte Aptos account address) is serialized into a HexEncodedBytes string.
 * For example:
 * - `0x1`
 * - `0x1668f6be25668c1a17cd8caf6b8d2f25`
 *
 * Move `vector` type value is serialized into `array`, except `vector<u8>` which is serialized into a
 * HexEncodedBytes string with `0x` prefix.
 * For example:
 * - `vector<u64>{255, 255}` => `["255", "255"]`
 * - `vector<u8>{255, 255}` => `0xffff`
 *
 * Move `struct` type value is serialized into `object` that looks like this (except some Move stdlib types, see the following section):
 * ```json
 * {
     * field1_name: field1_value,
     * field2_name: field2_value,
     * ......
     * }
     * ```
     *
     * For example:
     * `{ "created": "0xa550c18", "role_id": "0" }`
     *
     * **Special serialization for Move stdlib types**:
     * - [0x1::string::String](https://github.com/aptos-labs/aptos-core/blob/main/language/move-stdlib/docs/ascii.md)
     * is serialized into `string`. For example, struct value `0x1::string::String{bytes: b"Hello World!"}`
     * is serialized as `"Hello World!"` in JSON.
     *
     */
declare type MoveStructValue = {};

/**
 * A parsed Move resource
 */
declare type MoveResource = {
    type: MoveStructTag;
    data: MoveStructValue;
};

/**
 * Write a resource or update an existing one
 */
declare type WriteResource = {
    address: Address;
    /**
     * State key hash
     */
    state_key_hash: string;
    data: MoveResource;
};

declare type WriteSetChange_WriteResource = ({
    type: string;
} & WriteResource);

/**
 * Decoded table data
 */
declare type DecodedTableData = {
    /**
     * Key of table in JSON
     */
    key: any;
    /**
     * Type of key
     */
    key_type: string;
    /**
     * Value of table in JSON
     */
    value: any;
    /**
     * Type of value
     */
    value_type: string;
};

/**
 * Change set to write a table item
 */
declare type WriteTableItem = {
    state_key_hash: string;
    handle: HexEncodedBytes;
    key: HexEncodedBytes;
    value: HexEncodedBytes;
    data?: DecodedTableData;
};

declare type WriteSetChange_WriteTableItem = ({
    type: string;
} & WriteTableItem);

/**
 * A final state change of a transaction on a resource or module
 */
declare type WriteSetChange = (WriteSetChange_DeleteModule | WriteSetChange_DeleteResource | WriteSetChange_DeleteTableItem | WriteSetChange_WriteModule | WriteSetChange_WriteResource | WriteSetChange_WriteTableItem);

/**
 * A block metadata transaction
 *
 * This signifies the beginning of a block, and contains information
 * about the specific block
 */
declare type BlockMetadataTransaction = {
    version: U64$1;
    hash: HashValue;
    state_change_hash: HashValue;
    event_root_hash: HashValue;
    state_checkpoint_hash?: HashValue;
    gas_used: U64$1;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: HashValue;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    id: HashValue;
    epoch: U64$1;
    round: U64$1;
    /**
     * The events emitted at the block creation
     */
    events: Array<Event>;
    /**
     * Previous block votes
     */
    previous_block_votes_bitvec: Array<number>;
    proposer: Address;
    /**
     * The indices of the proposers who failed to propose
     */
    failed_proposer_indices: Array<number>;
    timestamp: U64$1;
};

declare type Transaction_BlockMetadataTransaction = ({
    type: string;
} & BlockMetadataTransaction);

declare type DirectWriteSet = {
    changes: Array<WriteSetChange>;
    events: Array<Event>;
};

declare type WriteSet_DirectWriteSet = ({
    type: string;
} & DirectWriteSet);

/**
 * Move script bytecode
 */
declare type MoveScriptBytecode = {
    bytecode: HexEncodedBytes;
    abi?: MoveFunction;
};

/**
 * Payload which runs a script that can run multiple functions
 */
declare type ScriptPayload = {
    code: MoveScriptBytecode;
    /**
     * Type arguments of the function
     */
    type_arguments: Array<MoveType>;
    /**
     * Arguments of the function
     */
    arguments: Array<any>;
};

declare type ScriptWriteSet = {
    execute_as: Address;
    script: ScriptPayload;
};

declare type WriteSet_ScriptWriteSet = ({
    type: string;
} & ScriptWriteSet);

/**
 * The associated writeset with a payload
 */
declare type WriteSet$1 = (WriteSet_ScriptWriteSet | WriteSet_DirectWriteSet);

/**
 * A writeset payload, used only for genesis
 */
declare type WriteSetPayload = {
    write_set: WriteSet$1;
};

declare type GenesisPayload_WriteSetPayload = ({
    type: string;
} & WriteSetPayload);

/**
 * The writeset payload of the Genesis transaction
 */
declare type GenesisPayload = GenesisPayload_WriteSetPayload;

/**
 * The genesis transaction
 *
 * This only occurs at the genesis transaction (version 0)
 */
declare type GenesisTransaction = {
    version: U64$1;
    hash: HashValue;
    state_change_hash: HashValue;
    event_root_hash: HashValue;
    state_checkpoint_hash?: HashValue;
    gas_used: U64$1;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: HashValue;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    payload: GenesisPayload;
    /**
     * Events emitted during genesis
     */
    events: Array<Event>;
};

declare type Transaction_GenesisTransaction = ({
    type: string;
} & GenesisTransaction);

/**
 * Entry function id is string representation of a entry function defined on-chain.
 *
 * Format: `{address}::{module name}::{function name}`
 *
 * Both `module name` and `function name` are case-sensitive.
 *
 */
declare type EntryFunctionId = string;

/**
 * Payload which runs a single entry function
 */
declare type EntryFunctionPayload = {
    function: EntryFunctionId;
    /**
     * Type arguments of the function
     */
    type_arguments: Array<MoveType>;
    /**
     * Arguments of the function
     */
    arguments: Array<any>;
};

declare type TransactionPayload_EntryFunctionPayload = ({
    type: string;
} & EntryFunctionPayload);

declare type ModuleBundlePayload = {
    modules: Array<MoveModuleBytecode>;
};

declare type TransactionPayload_ModuleBundlePayload = ({
    type: string;
} & ModuleBundlePayload);

declare type MultisigTransactionPayload = EntryFunctionPayload;

/**
 * A multisig transaction that allows an owner of a multisig account to execute a pre-approved
 * transaction as the multisig account.
 */
declare type MultisigPayload = {
    multisig_address: Address;
    transaction_payload?: MultisigTransactionPayload;
};

declare type TransactionPayload_MultisigPayload = ({
    type: string;
} & MultisigPayload);

declare type TransactionPayload_ScriptPayload = ({
    type: string;
} & ScriptPayload);

/**
 * An enum of the possible transaction payloads
 */
declare type TransactionPayload$1 = (TransactionPayload_EntryFunctionPayload | TransactionPayload_ScriptPayload | TransactionPayload_ModuleBundlePayload | TransactionPayload_MultisigPayload);

declare type TransactionSignature_Ed25519Signature = ({
    type: string;
} & Ed25519Signature$1);

/**
 * Fee payer signature for fee payer transactions
 *
 * This allows you to have transactions across multiple accounts and with a fee payer
 */
declare type FeePayerSignature = {
    sender: AccountSignature;
    /**
     * The other involved parties' addresses
     */
    secondary_signer_addresses: Array<Address>;
    /**
     * The associated signatures, in the same order as the secondary addresses
     */
    secondary_signers: Array<AccountSignature>;
    fee_payer_address: Address;
    fee_payer_signer: AccountSignature;
};

declare type TransactionSignature_FeePayerSignature = ({
    type: string;
} & FeePayerSignature);

/**
 * Multi agent signature for multi agent transactions
 *
 * This allows you to have transactions across multiple accounts
 */
declare type MultiAgentSignature = {
    sender: AccountSignature;
    /**
     * The other involved parties' addresses
     */
    secondary_signer_addresses: Array<Address>;
    /**
     * The associated signatures, in the same order as the secondary addresses
     */
    secondary_signers: Array<AccountSignature>;
};

declare type TransactionSignature_MultiAgentSignature = ({
    type: string;
} & MultiAgentSignature);

declare type TransactionSignature_MultiEd25519Signature = ({
    type: string;
} & MultiEd25519Signature$1);

/**
 * An enum representing the different transaction signatures available
 */
declare type TransactionSignature = (TransactionSignature_Ed25519Signature | TransactionSignature_MultiEd25519Signature | TransactionSignature_MultiAgentSignature | TransactionSignature_FeePayerSignature);

/**
 * A transaction waiting in mempool
 */
declare type PendingTransaction = {
    hash: HashValue;
    sender: Address;
    sequence_number: U64$1;
    max_gas_amount: U64$1;
    gas_unit_price: U64$1;
    expiration_timestamp_secs: U64$1;
    payload: TransactionPayload$1;
    signature?: TransactionSignature;
};

declare type Transaction_PendingTransaction = ({
    type: string;
} & PendingTransaction);

/**
 * A state checkpoint transaction
 */
declare type StateCheckpointTransaction = {
    version: U64$1;
    hash: HashValue;
    state_change_hash: HashValue;
    event_root_hash: HashValue;
    state_checkpoint_hash?: HashValue;
    gas_used: U64$1;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: HashValue;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    timestamp: U64$1;
};

declare type Transaction_StateCheckpointTransaction = ({
    type: string;
} & StateCheckpointTransaction);

/**
 * A transaction submitted by a user to change the state of the blockchain
 */
declare type UserTransaction$1 = {
    version: U64$1;
    hash: HashValue;
    state_change_hash: HashValue;
    event_root_hash: HashValue;
    state_checkpoint_hash?: HashValue;
    gas_used: U64$1;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: HashValue;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    sender: Address;
    sequence_number: U64$1;
    max_gas_amount: U64$1;
    gas_unit_price: U64$1;
    expiration_timestamp_secs: U64$1;
    payload: TransactionPayload$1;
    signature?: TransactionSignature;
    /**
     * Events generated by the transaction
     */
    events: Array<Event>;
    timestamp: U64$1;
};

declare type Transaction_UserTransaction = ({
    type: string;
} & UserTransaction$1);

/**
 * Enum of the different types of transactions in Aptos
 */
declare type Transaction$1 = (Transaction_PendingTransaction | Transaction_UserTransaction | Transaction_GenesisTransaction | Transaction_BlockMetadataTransaction | Transaction_StateCheckpointTransaction);

/**
 * A Block with or without transactions
 *
 * This contains the information about a transactions along with
 * associated transactions if requested
 */
declare type Block = {
    block_height: U64$1;
    block_hash: HashValue;
    block_timestamp: U64$1;
    first_version: U64$1;
    last_version: U64$1;
    /**
     * The transactions in the block in sequential order
     */
    transactions?: Array<Transaction$1>;
};

/**
 * Request to encode a submission
 */
declare type EncodeSubmissionRequest = {
    sender: Address;
    sequence_number: U64$1;
    max_gas_amount: U64$1;
    gas_unit_price: U64$1;
    expiration_timestamp_secs: U64$1;
    payload: TransactionPayload$1;
    /**
     * Secondary signer accounts of the request for Multi-agent
     */
    secondary_signers?: Array<Address>;
};

/**
 * Struct holding the outputs of the estimate gas API
 */
declare type GasEstimation = {
    /**
     * The deprioritized estimate for the gas unit price
     */
    deprioritized_gas_estimate?: number;
    /**
     * The current estimate for the gas unit price
     */
    gas_estimate: number;
    /**
     * The prioritized estimate for the gas unit price
     */
    prioritized_gas_estimate?: number;
};

/**
 * Representation of a successful healthcheck
 */
declare type HealthCheckSuccess = {
    message: string;
};

declare enum RoleType {
    VALIDATOR = "validator",
    FULL_NODE = "full_node"
}

/**
 * The struct holding all data returned to the client by the
 * index endpoint (i.e., GET "/").  Only for responding in JSON
 */
declare type IndexResponse = {
    /**
     * Chain ID of the current chain
     */
    chain_id: number;
    epoch: U64$1;
    ledger_version: U64$1;
    oldest_ledger_version: U64$1;
    ledger_timestamp: U64$1;
    node_role: RoleType;
    oldest_block_height: U64$1;
    block_height: U64$1;
    /**
     * Git hash of the build of the API endpoint.  Can be used to determine the exact
     * software version used by the API endpoint.
     */
    git_hash?: string;
};

/**
 * A string containing a 128-bit unsigned integer.
 *
 * We represent u128 values as a string to ensure compatibility with languages such
 * as JavaScript that do not parse u128s in JSON natively.
 *
 */
declare type U128 = string;

/**
 * A string containing a 256-bit unsigned integer.
 *
 * We represent u256 values as a string to ensure compatibility with languages such
 * as JavaScript that do not parse u256s in JSON natively.
 *
 */
declare type U256 = string;

/**
 * An enum of the possible Move value types
 */
declare type MoveValue = (number | U64$1 | U128 | U256 | boolean | Address | Array<MoveValue> | HexEncodedBytes | MoveStructValue | string);

/**
 * Table Item request for the GetTableItemRaw API
 */
declare type RawTableItemRequest = {
    key: HexEncodedBytes;
};

/**
 * Representation of a StateKey as a hex string. This is used for cursor based pagination.
 *
 */
declare type StateKeyWrapper = string;

/**
 * A request to submit a transaction
 *
 * This requires a transaction and a signature of it
 */
declare type SubmitTransactionRequest = {
    sender: Address;
    sequence_number: U64$1;
    max_gas_amount: U64$1;
    gas_unit_price: U64$1;
    expiration_timestamp_secs: U64$1;
    payload: TransactionPayload$1;
    signature: TransactionSignature;
};

/**
 * Table Item request for the GetTableItem API
 */
declare type TableItemRequest = {
    key_type: MoveType;
    value_type: MoveType;
    /**
     * The value of the table item's key
     */
    key: any;
};

/**
 * Information telling which batch submission transactions failed
 */
declare type TransactionsBatchSingleSubmissionFailure = {
    error: AptosError;
    /**
     * The index of which transaction failed, same as submission order
     */
    transaction_index: number;
};

/**
 * Batch transaction submission result
 *
 * Tells which transactions failed
 */
declare type TransactionsBatchSubmissionResult = {
    /**
     * Summary of the failed transactions
     */
    transaction_failures: Array<TransactionsBatchSingleSubmissionFailure>;
};

/**
 * An event from a transaction with a version
 */
declare type VersionedEvent = {
    version: U64$1;
    guid: EventGuid;
    sequence_number: U64$1;
    type: MoveType;
    /**
     * The JSON representation of the event
     */
    data: any;
};

/**
 * View request for the Move View Function API
 */
declare type ViewRequest = {
    function: EntryFunctionId;
    /**
     * Type arguments of the function
     */
    type_arguments: Array<MoveType>;
    /**
     * Arguments of the function
     */
    arguments: Array<any>;
};

type index$1_AccountData = AccountData;
type index$1_AccountSignature = AccountSignature;
type index$1_AccountSignature_Ed25519Signature = AccountSignature_Ed25519Signature;
type index$1_AccountSignature_MultiEd25519Signature = AccountSignature_MultiEd25519Signature;
type index$1_Address = Address;
type index$1_AptosError = AptosError;
type index$1_AptosErrorCode = AptosErrorCode;
declare const index$1_AptosErrorCode: typeof AptosErrorCode;
type index$1_Block = Block;
type index$1_BlockMetadataTransaction = BlockMetadataTransaction;
type index$1_DecodedTableData = DecodedTableData;
type index$1_DeletedTableData = DeletedTableData;
type index$1_DeleteModule = DeleteModule;
type index$1_DeleteResource = DeleteResource;
type index$1_DeleteTableItem = DeleteTableItem;
type index$1_DirectWriteSet = DirectWriteSet;
type index$1_EncodeSubmissionRequest = EncodeSubmissionRequest;
type index$1_EntryFunctionId = EntryFunctionId;
type index$1_EntryFunctionPayload = EntryFunctionPayload;
type index$1_Event = Event;
type index$1_EventGuid = EventGuid;
type index$1_FeePayerSignature = FeePayerSignature;
type index$1_GasEstimation = GasEstimation;
type index$1_GenesisPayload = GenesisPayload;
type index$1_GenesisPayload_WriteSetPayload = GenesisPayload_WriteSetPayload;
type index$1_GenesisTransaction = GenesisTransaction;
type index$1_HashValue = HashValue;
type index$1_HealthCheckSuccess = HealthCheckSuccess;
type index$1_HexEncodedBytes = HexEncodedBytes;
type index$1_IdentifierWrapper = IdentifierWrapper;
type index$1_IndexResponse = IndexResponse;
type index$1_ModuleBundlePayload = ModuleBundlePayload;
type index$1_MoveAbility = MoveAbility;
type index$1_MoveFunction = MoveFunction;
type index$1_MoveFunctionGenericTypeParam = MoveFunctionGenericTypeParam;
type index$1_MoveFunctionVisibility = MoveFunctionVisibility;
declare const index$1_MoveFunctionVisibility: typeof MoveFunctionVisibility;
type index$1_MoveModule = MoveModule;
type index$1_MoveModuleBytecode = MoveModuleBytecode;
type index$1_MoveModuleId = MoveModuleId;
type index$1_MoveResource = MoveResource;
type index$1_MoveScriptBytecode = MoveScriptBytecode;
type index$1_MoveStruct = MoveStruct;
type index$1_MoveStructField = MoveStructField;
type index$1_MoveStructGenericTypeParam = MoveStructGenericTypeParam;
type index$1_MoveStructTag = MoveStructTag;
type index$1_MoveStructValue = MoveStructValue;
type index$1_MoveType = MoveType;
type index$1_MoveValue = MoveValue;
type index$1_MultiAgentSignature = MultiAgentSignature;
type index$1_MultisigPayload = MultisigPayload;
type index$1_MultisigTransactionPayload = MultisigTransactionPayload;
type index$1_PendingTransaction = PendingTransaction;
type index$1_RawTableItemRequest = RawTableItemRequest;
type index$1_RoleType = RoleType;
declare const index$1_RoleType: typeof RoleType;
type index$1_ScriptPayload = ScriptPayload;
type index$1_ScriptWriteSet = ScriptWriteSet;
type index$1_StateCheckpointTransaction = StateCheckpointTransaction;
type index$1_StateKeyWrapper = StateKeyWrapper;
type index$1_SubmitTransactionRequest = SubmitTransactionRequest;
type index$1_TableItemRequest = TableItemRequest;
type index$1_Transaction_BlockMetadataTransaction = Transaction_BlockMetadataTransaction;
type index$1_Transaction_GenesisTransaction = Transaction_GenesisTransaction;
type index$1_Transaction_PendingTransaction = Transaction_PendingTransaction;
type index$1_Transaction_StateCheckpointTransaction = Transaction_StateCheckpointTransaction;
type index$1_Transaction_UserTransaction = Transaction_UserTransaction;
type index$1_TransactionPayload_EntryFunctionPayload = TransactionPayload_EntryFunctionPayload;
type index$1_TransactionPayload_ModuleBundlePayload = TransactionPayload_ModuleBundlePayload;
type index$1_TransactionPayload_MultisigPayload = TransactionPayload_MultisigPayload;
type index$1_TransactionPayload_ScriptPayload = TransactionPayload_ScriptPayload;
type index$1_TransactionsBatchSingleSubmissionFailure = TransactionsBatchSingleSubmissionFailure;
type index$1_TransactionsBatchSubmissionResult = TransactionsBatchSubmissionResult;
type index$1_TransactionSignature = TransactionSignature;
type index$1_TransactionSignature_Ed25519Signature = TransactionSignature_Ed25519Signature;
type index$1_TransactionSignature_FeePayerSignature = TransactionSignature_FeePayerSignature;
type index$1_TransactionSignature_MultiAgentSignature = TransactionSignature_MultiAgentSignature;
type index$1_TransactionSignature_MultiEd25519Signature = TransactionSignature_MultiEd25519Signature;
type index$1_U128 = U128;
type index$1_U256 = U256;
type index$1_VersionedEvent = VersionedEvent;
type index$1_ViewRequest = ViewRequest;
type index$1_WriteModule = WriteModule;
type index$1_WriteResource = WriteResource;
type index$1_WriteSet_DirectWriteSet = WriteSet_DirectWriteSet;
type index$1_WriteSet_ScriptWriteSet = WriteSet_ScriptWriteSet;
type index$1_WriteSetChange = WriteSetChange;
type index$1_WriteSetChange_DeleteModule = WriteSetChange_DeleteModule;
type index$1_WriteSetChange_DeleteResource = WriteSetChange_DeleteResource;
type index$1_WriteSetChange_DeleteTableItem = WriteSetChange_DeleteTableItem;
type index$1_WriteSetChange_WriteModule = WriteSetChange_WriteModule;
type index$1_WriteSetChange_WriteResource = WriteSetChange_WriteResource;
type index$1_WriteSetChange_WriteTableItem = WriteSetChange_WriteTableItem;
type index$1_WriteSetPayload = WriteSetPayload;
type index$1_WriteTableItem = WriteTableItem;
declare namespace index$1 {
  export {
    index$1_AccountData as AccountData,
    index$1_AccountSignature as AccountSignature,
    index$1_AccountSignature_Ed25519Signature as AccountSignature_Ed25519Signature,
    index$1_AccountSignature_MultiEd25519Signature as AccountSignature_MultiEd25519Signature,
    index$1_Address as Address,
    index$1_AptosError as AptosError,
    index$1_AptosErrorCode as AptosErrorCode,
    index$1_Block as Block,
    index$1_BlockMetadataTransaction as BlockMetadataTransaction,
    index$1_DecodedTableData as DecodedTableData,
    index$1_DeletedTableData as DeletedTableData,
    index$1_DeleteModule as DeleteModule,
    index$1_DeleteResource as DeleteResource,
    index$1_DeleteTableItem as DeleteTableItem,
    index$1_DirectWriteSet as DirectWriteSet,
    Ed25519Signature$1 as Ed25519Signature,
    index$1_EncodeSubmissionRequest as EncodeSubmissionRequest,
    index$1_EntryFunctionId as EntryFunctionId,
    index$1_EntryFunctionPayload as EntryFunctionPayload,
    index$1_Event as Event,
    index$1_EventGuid as EventGuid,
    index$1_FeePayerSignature as FeePayerSignature,
    index$1_GasEstimation as GasEstimation,
    index$1_GenesisPayload as GenesisPayload,
    index$1_GenesisPayload_WriteSetPayload as GenesisPayload_WriteSetPayload,
    index$1_GenesisTransaction as GenesisTransaction,
    index$1_HashValue as HashValue,
    index$1_HealthCheckSuccess as HealthCheckSuccess,
    index$1_HexEncodedBytes as HexEncodedBytes,
    index$1_IdentifierWrapper as IdentifierWrapper,
    index$1_IndexResponse as IndexResponse,
    index$1_ModuleBundlePayload as ModuleBundlePayload,
    index$1_MoveAbility as MoveAbility,
    index$1_MoveFunction as MoveFunction,
    index$1_MoveFunctionGenericTypeParam as MoveFunctionGenericTypeParam,
    index$1_MoveFunctionVisibility as MoveFunctionVisibility,
    index$1_MoveModule as MoveModule,
    index$1_MoveModuleBytecode as MoveModuleBytecode,
    index$1_MoveModuleId as MoveModuleId,
    index$1_MoveResource as MoveResource,
    index$1_MoveScriptBytecode as MoveScriptBytecode,
    index$1_MoveStruct as MoveStruct,
    index$1_MoveStructField as MoveStructField,
    index$1_MoveStructGenericTypeParam as MoveStructGenericTypeParam,
    index$1_MoveStructTag as MoveStructTag,
    index$1_MoveStructValue as MoveStructValue,
    index$1_MoveType as MoveType,
    index$1_MoveValue as MoveValue,
    index$1_MultiAgentSignature as MultiAgentSignature,
    MultiEd25519Signature$1 as MultiEd25519Signature,
    index$1_MultisigPayload as MultisigPayload,
    index$1_MultisigTransactionPayload as MultisigTransactionPayload,
    index$1_PendingTransaction as PendingTransaction,
    index$1_RawTableItemRequest as RawTableItemRequest,
    index$1_RoleType as RoleType,
    index$1_ScriptPayload as ScriptPayload,
    index$1_ScriptWriteSet as ScriptWriteSet,
    index$1_StateCheckpointTransaction as StateCheckpointTransaction,
    index$1_StateKeyWrapper as StateKeyWrapper,
    index$1_SubmitTransactionRequest as SubmitTransactionRequest,
    index$1_TableItemRequest as TableItemRequest,
    Transaction$1 as Transaction,
    index$1_Transaction_BlockMetadataTransaction as Transaction_BlockMetadataTransaction,
    index$1_Transaction_GenesisTransaction as Transaction_GenesisTransaction,
    index$1_Transaction_PendingTransaction as Transaction_PendingTransaction,
    index$1_Transaction_StateCheckpointTransaction as Transaction_StateCheckpointTransaction,
    index$1_Transaction_UserTransaction as Transaction_UserTransaction,
    TransactionPayload$1 as TransactionPayload,
    index$1_TransactionPayload_EntryFunctionPayload as TransactionPayload_EntryFunctionPayload,
    index$1_TransactionPayload_ModuleBundlePayload as TransactionPayload_ModuleBundlePayload,
    index$1_TransactionPayload_MultisigPayload as TransactionPayload_MultisigPayload,
    index$1_TransactionPayload_ScriptPayload as TransactionPayload_ScriptPayload,
    index$1_TransactionsBatchSingleSubmissionFailure as TransactionsBatchSingleSubmissionFailure,
    index$1_TransactionsBatchSubmissionResult as TransactionsBatchSubmissionResult,
    index$1_TransactionSignature as TransactionSignature,
    index$1_TransactionSignature_Ed25519Signature as TransactionSignature_Ed25519Signature,
    index$1_TransactionSignature_FeePayerSignature as TransactionSignature_FeePayerSignature,
    index$1_TransactionSignature_MultiAgentSignature as TransactionSignature_MultiAgentSignature,
    index$1_TransactionSignature_MultiEd25519Signature as TransactionSignature_MultiEd25519Signature,
    index$1_U128 as U128,
    index$1_U256 as U256,
    U64$1 as U64,
    UserTransaction$1 as UserTransaction,
    index$1_VersionedEvent as VersionedEvent,
    index$1_ViewRequest as ViewRequest,
    index$1_WriteModule as WriteModule,
    index$1_WriteResource as WriteResource,
    WriteSet$1 as WriteSet,
    index$1_WriteSet_DirectWriteSet as WriteSet_DirectWriteSet,
    index$1_WriteSet_ScriptWriteSet as WriteSet_ScriptWriteSet,
    index$1_WriteSetChange as WriteSetChange,
    index$1_WriteSetChange_DeleteModule as WriteSetChange_DeleteModule,
    index$1_WriteSetChange_DeleteResource as WriteSetChange_DeleteResource,
    index$1_WriteSetChange_DeleteTableItem as WriteSetChange_DeleteTableItem,
    index$1_WriteSetChange_WriteModule as WriteSetChange_WriteModule,
    index$1_WriteSetChange_WriteResource as WriteSetChange_WriteResource,
    index$1_WriteSetChange_WriteTableItem as WriteSetChange_WriteTableItem,
    index$1_WriteSetPayload as WriteSetPayload,
    index$1_WriteTableItem as WriteTableItem,
  };
}

declare type MaybeHexString = HexString | string | HexEncodedBytes;
/**
 * A util class for working with hex strings.
 * Hex strings are strings that are prefixed with `0x`
 */
declare class HexString {
    private readonly hexString;
    /**
     * Creates new hex string from Buffer
     * @param buffer A buffer to convert
     * @returns New HexString
     */
    static fromBuffer(buffer: Uint8Array): HexString;
    /**
     * Creates new hex string from Uint8Array
     * @param arr Uint8Array to convert
     * @returns New HexString
     */
    static fromUint8Array(arr: Uint8Array): HexString;
    /**
     * Ensures `hexString` is instance of `HexString` class
     * @param hexString String to check
     * @returns New HexString if `hexString` is regular string or `hexString` if it is HexString instance
     * @example
     * ```
     *  const regularString = "string";
     *  const hexString = new HexString("string"); // "0xstring"
     *  HexString.ensure(regularString); // "0xstring"
     *  HexString.ensure(hexString); // "0xstring"
     * ```
     */
    static ensure(hexString: MaybeHexString): HexString;
    /**
     * Creates new HexString instance from regular string. If specified string already starts with "0x" prefix,
     * it will not add another one
     * @param hexString String to convert
     * @example
     * ```
     *  const string = "string";
     *  new HexString(string); // "0xstring"
     * ```
     */
    constructor(hexString: string | HexEncodedBytes);
    /**
     * Getter for inner hexString
     * @returns Inner hex string
     */
    hex(): string;
    /**
     * Getter for inner hexString without prefix
     * @returns Inner hex string without prefix
     * @example
     * ```
     *  const hexString = new HexString("string"); // "0xstring"
     *  hexString.noPrefix(); // "string"
     * ```
     */
    noPrefix(): string;
    /**
     * Overrides default `toString` method
     * @returns Inner hex string
     */
    toString(): string;
    /**
     * Trimmes extra zeroes in the begining of a string
     * @returns Inner hexString without leading zeroes
     * @example
     * ```
     *  new HexString("0x000000string").toShortString(); // result = "0xstring"
     * ```
     */
    toShortString(): string;
    /**
     * Converts hex string to a Uint8Array
     * @returns Uint8Array from inner hexString without prefix
     */
    toUint8Array(): Uint8Array;
}

interface AptosAccountObject {
    address?: HexEncodedBytes;
    publicKeyHex?: HexEncodedBytes;
    privateKeyHex: HexEncodedBytes;
}
/**
 * Class for creating and managing Aptos account
 */
declare class AptosAccount {
    /**
     * A private key and public key, associated with the given account
     */
    readonly signingKey: nacl.SignKeyPair;
    /**
     * Address associated with the given account
     */
    private readonly accountAddress;
    static fromAptosAccountObject(obj: AptosAccountObject): AptosAccount;
    /**
     * Test derive path
     */
    static isValidPath(path: string): boolean;
    /**
     * Creates new account with bip44 path and mnemonics,
     * @param path. (e.g. m/44'/637'/0'/0'/0')
     * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
     * @param mnemonics.
     * @returns AptosAccount
     */
    static fromDerivePath(path: string, mnemonics: string): AptosAccount;
    /**
     * Creates new account instance. Constructor allows passing in an address,
     * to handle account key rotation, where auth_key != public_key
     * @param privateKeyBytes  Private key from which account key pair will be generated.
     * If not specified, new key pair is going to be created.
     * @param address Account address (e.g. 0xe8012714cd17606cee7188a2a365eef3fe760be598750678c8c5954eb548a591).
     * If not specified, a new one will be generated from public key
     */
    constructor(privateKeyBytes?: Uint8Array | undefined, address?: MaybeHexString);
    /**
     * This is the key by which Aptos account is referenced.
     * It is the 32-byte of the SHA-3 256 cryptographic hash
     * of the public key(s) concatenated with a signature scheme identifier byte
     * @returns Address associated with the given account
     */
    address(): HexString;
    /**
     * This key enables account owners to rotate their private key(s)
     * associated with the account without changing the address that hosts their account.
     * See here for more info: {@link https://aptos.dev/concepts/accounts#single-signer-authentication}
     * @returns Authentication key for the associated account
     */
    authKey(): HexString;
    /**
     * Takes source address and seeds and returns the resource account address
     * @param sourceAddress Address used to derive the resource account
     * @param seed The seed bytes
     * @returns The resource account address
     */
    static getResourceAccountAddress(sourceAddress: MaybeHexString, seed: Uint8Array): HexString;
    /**
     * Takes creator address and collection name and returns the collection id hash.
     * Collection id hash are generated as sha256 hash of (`creator_address::collection_name`)
     *
     * @param creatorAddress Collection creator address
     * @param collectionName The collection name
     * @returns The collection id hash
     */
    static getCollectionID(creatorAddress: MaybeHexString, collectionName: string): HexString;
    /**
     * This key is generated with Ed25519 scheme.
     * Public key is used to check a signature of transaction, signed by given account
     * @returns The public key for the associated account
     */
    pubKey(): HexString;
    /**
     * Signs specified `buffer` with account's private key
     * @param buffer A buffer to sign
     * @returns A signature HexString
     */
    signBuffer(buffer: Uint8Array): HexString;
    /**
     * Signs specified `hexString` with account's private key
     * @param hexString A regular string or HexString to sign
     * @returns A signature HexString
     */
    signHexString(hexString: MaybeHexString): HexString;
    /**
     * Verifies the signature of the message with the public key of the account
     * @param message a signed message
     * @param signature the signature of the message
     */
    verifySignature(message: MaybeHexString, signature: MaybeHexString): boolean;
    /**
     * Derives account address, public key and private key
     * @returns AptosAccountObject instance.
     * @example An example of the returned AptosAccountObject object
     * ```
     * {
     *    address: "0xe8012714cd17606cee7188a2a365eef3fe760be598750678c8c5954eb548a591",
     *    publicKeyHex: "0xf56d8524faf79fbc0f48c13aeed3b0ce5dd376b4db93b8130a107c0a5e04ba04",
     *    privateKeyHex: `0x009c9f7c992a06cfafe916f125d8adb7a395fca243e264a8e56a4b3e6accf940
     *      d2b11e9ece3049ce60e3c7b4a1c58aebfa9298e29a30a58a67f1998646135204`
     * }
     * ```
     */
    toPrivateKeyObject(): AptosAccountObject;
}
declare function getAddressFromAccountOrAddress(accountOrAddress: AptosAccount | MaybeHexString): HexString;

declare type GetAccountCoinsDataQuery = {
    __typename?: 'query_root';
    current_coin_balances: Array<{
        __typename?: 'current_coin_balances';
        amount: any;
        coin_type: string;
        coin_info?: {
            __typename?: 'coin_infos';
            name: string;
            decimals: number;
            symbol: string;
        } | null;
    }>;
};
declare type GetAccountCurrentTokensQuery = {
    __typename?: 'query_root';
    current_token_ownerships: Array<{
        __typename?: 'current_token_ownerships';
        amount: any;
        last_transaction_version: any;
        property_version: any;
        current_token_data?: {
            __typename?: 'current_token_datas';
            creator_address: string;
            collection_name: string;
            description: string;
            metadata_uri: string;
            name: string;
            token_data_id_hash: string;
            collection_data_id_hash: string;
        } | null;
        current_collection_data?: {
            __typename?: 'current_collection_datas';
            metadata_uri: string;
            supply: any;
            description: string;
            collection_name: string;
            collection_data_id_hash: string;
            table_handle: string;
            creator_address: string;
        } | null;
    }>;
};
declare type GetAccountTokensCountQuery = {
    __typename?: 'query_root';
    current_token_ownerships_aggregate: {
        __typename?: 'current_token_ownerships_aggregate';
        aggregate?: {
            __typename?: 'current_token_ownerships_aggregate_fields';
            count: number;
        } | null;
    };
};
declare type GetAccountTransactionsCountQuery = {
    __typename?: 'query_root';
    move_resources_aggregate: {
        __typename?: 'move_resources_aggregate';
        aggregate?: {
            __typename?: 'move_resources_aggregate_fields';
            count: number;
        } | null;
    };
};
declare type GetAccountTransactionsDataQuery = {
    __typename?: 'query_root';
    move_resources: Array<{
        __typename?: 'move_resources';
        transaction_version: any;
    }>;
};
declare type GetCollectionDataQuery = {
    __typename?: 'query_root';
    current_collections_v2: Array<{
        __typename?: 'current_collections_v2';
        collection_id: string;
        token_standard: string;
        collection_name: string;
        creator_address: string;
        current_supply: any;
        description: string;
        uri: string;
    }>;
};
declare type GetCollectionsWithOwnedTokensQuery = {
    __typename?: 'query_root';
    current_collection_ownership_v2_view: Array<{
        __typename?: 'current_collection_ownership_v2_view';
        distinct_tokens?: any | null;
        last_transaction_version?: any | null;
        current_collection?: {
            __typename?: 'current_collections_v2';
            creator_address: string;
            collection_name: string;
            token_standard: string;
            collection_id: string;
            description: string;
            table_handle_v1?: string | null;
            uri: string;
            total_minted_v2?: any | null;
            max_supply?: any | null;
        } | null;
    }>;
};
declare type GetDelegatedStakingActivitiesQuery = {
    __typename?: 'query_root';
    delegated_staking_activities: Array<{
        __typename?: 'delegated_staking_activities';
        amount: any;
        delegator_address: string;
        event_index: any;
        event_type: string;
        pool_address: string;
        transaction_version: any;
    }>;
};
declare type GetIndexerLedgerInfoQuery = {
    __typename?: 'query_root';
    ledger_infos: Array<{
        __typename?: 'ledger_infos';
        chain_id: any;
    }>;
};
declare type GetNumberOfDelegatorsQuery = {
    __typename?: 'query_root';
    num_active_delegator_per_pool: Array<{
        __typename?: 'num_active_delegator_per_pool';
        num_active_delegator?: any | null;
    }>;
};
declare type GetOwnedTokensQuery = {
    __typename?: 'query_root';
    current_token_ownerships_v2: Array<{
        __typename?: 'current_token_ownerships_v2';
        token_standard: string;
        is_fungible_v2?: boolean | null;
        is_soulbound_v2?: boolean | null;
        property_version_v1: any;
        table_type_v1?: string | null;
        token_properties_mutated_v1?: any | null;
        amount: any;
        last_transaction_timestamp: any;
        last_transaction_version: any;
        storage_id: string;
        owner_address: string;
        current_token_data?: {
            __typename?: 'current_token_datas_v2';
            token_name: string;
            token_data_id: string;
            token_uri: string;
            token_properties: any;
            supply: any;
            maximum?: any | null;
            last_transaction_version: any;
            last_transaction_timestamp: any;
            largest_property_version_v1?: any | null;
            current_collection?: {
                __typename?: 'current_collections_v2';
                collection_name: string;
                creator_address: string;
                description: string;
                uri: string;
                collection_id: string;
                last_transaction_version: any;
                current_supply: any;
                mutable_description?: boolean | null;
                total_minted_v2?: any | null;
                table_handle_v1?: string | null;
                mutable_uri?: boolean | null;
            } | null;
        } | null;
    }>;
};
declare type GetTokenActivitiesQuery = {
    __typename?: 'query_root';
    token_activities: Array<{
        __typename?: 'token_activities';
        creator_address: string;
        collection_name: string;
        name: string;
        token_data_id_hash: string;
        collection_data_id_hash: string;
        from_address?: string | null;
        to_address?: string | null;
        transaction_version: any;
        transaction_timestamp: any;
        property_version: any;
        transfer_type: string;
        event_sequence_number: any;
        token_amount: any;
    }>;
};
declare type GetTokenActivitiesCountQuery = {
    __typename?: 'query_root';
    token_activities_aggregate: {
        __typename?: 'token_activities_aggregate';
        aggregate?: {
            __typename?: 'token_activities_aggregate_fields';
            count: number;
        } | null;
    };
};
declare type GetTokenCurrentOwnerDataQuery = {
    __typename?: 'query_root';
    current_token_ownerships_v2: Array<{
        __typename?: 'current_token_ownerships_v2';
        owner_address: string;
    }>;
};
declare type GetTokenDataQuery = {
    __typename?: 'query_root';
    current_token_datas_v2: Array<{
        __typename?: 'current_token_datas_v2';
        token_data_id: string;
        token_name: string;
        token_uri: string;
        token_properties: any;
        token_standard: string;
        largest_property_version_v1?: any | null;
        maximum?: any | null;
        is_fungible_v2?: boolean | null;
        supply: any;
        last_transaction_version: any;
        last_transaction_timestamp: any;
        current_collection?: {
            __typename?: 'current_collections_v2';
            collection_id: string;
            collection_name: string;
            creator_address: string;
            uri: string;
            current_supply: any;
        } | null;
    }>;
};
declare type GetTokenOwnedFromCollectionQuery = {
    __typename?: 'query_root';
    current_token_ownerships_v2: Array<{
        __typename?: 'current_token_ownerships_v2';
        token_standard: string;
        is_fungible_v2?: boolean | null;
        is_soulbound_v2?: boolean | null;
        property_version_v1: any;
        table_type_v1?: string | null;
        token_properties_mutated_v1?: any | null;
        amount: any;
        last_transaction_timestamp: any;
        last_transaction_version: any;
        storage_id: string;
        owner_address: string;
        current_token_data?: {
            __typename?: 'current_token_datas_v2';
            token_name: string;
            token_data_id: string;
            token_uri: string;
            token_properties: any;
            supply: any;
            maximum?: any | null;
            last_transaction_version: any;
            last_transaction_timestamp: any;
            largest_property_version_v1?: any | null;
            current_collection?: {
                __typename?: 'current_collections_v2';
                collection_name: string;
                creator_address: string;
                description: string;
                uri: string;
                collection_id: string;
                last_transaction_version: any;
                current_supply: any;
                mutable_description?: boolean | null;
                total_minted_v2?: any | null;
                table_handle_v1?: string | null;
                mutable_uri?: boolean | null;
            } | null;
        } | null;
    }>;
};
declare type GetTokenOwnersDataQuery = {
    __typename?: 'query_root';
    current_token_ownerships_v2: Array<{
        __typename?: 'current_token_ownerships_v2';
        owner_address: string;
    }>;
};
declare type GetTopUserTransactionsQuery = {
    __typename?: 'query_root';
    user_transactions: Array<{
        __typename?: 'user_transactions';
        version: any;
    }>;
};
declare type GetUserTransactionsQuery = {
    __typename?: 'query_root';
    user_transactions: Array<{
        __typename?: 'user_transactions';
        version: any;
    }>;
};

/**
 * Controls the number of results that are returned and the starting position of those results.
 * limit specifies the maximum number of items or records to return in a query result.
 * offset parameter specifies the starting position of the query result within the set of data.
 * For example, if you want to retrieve records 11-20,
 * you would set the offset parameter to 10 (i.e., the index of the first record to retrieve is 10)
 * and the limit parameter to 10 (i.e., the number of records to retrieve is 10))
 */
interface PaginationArgs$1 {
    offset?: AnyNumber;
    limit?: number;
}
declare type TokenStandard = "v1" | "v2";
declare type GraphqlQuery = {
    query: string;
    variables?: {};
};
/**
 * Provides methods for retrieving data from Aptos Indexer.
 * For more detailed Queries specification see
 * {@link https://cloud.hasura.io/public/graphiql?endpoint=https://indexer.mainnet.aptoslabs.com/v1/graphql}
 */
declare class IndexerClient {
    readonly endpoint: string;
    readonly config: ClientConfig | undefined;
    /**
     * @param endpoint URL of the Aptos Indexer API endpoint.
     */
    constructor(endpoint: string, config?: ClientConfig);
    /**
     * Indexer only accepts address in the long format, i.e a 66 chars long -> 0x<64 chars>
     * This method makes sure address is 66 chars long.
     * @param address
     */
    static validateAddress(address: string): void;
    /**
     * Makes axios client call to fetch data from Aptos Indexer.
     *
     * @param graphqlQuery A GraphQL query to pass in the `data` axios call.
     */
    queryIndexer<T>(graphqlQuery: GraphqlQuery): Promise<T>;
    /**
     * Queries Indexer Ledger Info
     *
     * @returns GetLedgerInfoQuery response type
     */
    getIndexerLedgerInfo(): Promise<GetIndexerLedgerInfoQuery>;
    /**
     * Queries an Aptos account's NFTs by owner address
     *
     * @param ownerAddress Hex-encoded 32 byte Aptos account address
     * @returns GetAccountCurrentTokensQuery response type
     */
    getAccountNFTs(ownerAddress: MaybeHexString, options?: PaginationArgs$1): Promise<GetAccountCurrentTokensQuery>;
    /**
     * Queries a token activities by token id hash
     *
     * @param idHash token id hash
     * @returns GetTokenActivitiesQuery response type
     */
    getTokenActivities(idHash: string, options?: PaginationArgs$1): Promise<GetTokenActivitiesQuery>;
    /**
     * Queries an account coin data
     *
     * @param ownerAddress Owner address
     * @returns GetAccountCoinsDataQuery response type
     */
    getAccountCoinsData(ownerAddress: MaybeHexString, options?: PaginationArgs$1): Promise<GetAccountCoinsDataQuery>;
    /**
     * Gets the count of tokens owned by an account
     *
     * @param ownerAddress Owner address
     * @returns AccountTokensCountQuery response type
     */
    getAccountTokensCount(ownerAddress: MaybeHexString): Promise<GetAccountTokensCountQuery>;
    /**
     * Gets the count of transactions submitted by an account
     *
     * @param address Account address
     * @returns GetAccountTransactionsCountQuery response type
     */
    getAccountTransactionsCount(accountAddress: MaybeHexString): Promise<GetAccountTransactionsCountQuery>;
    /**
     * Queries an account transactions data
     *
     * @param address Account address
     * @returns GetAccountTransactionsDataQuery response type
     */
    getAccountTransactionsData(accountAddress: MaybeHexString, options?: PaginationArgs$1): Promise<GetAccountTransactionsDataQuery>;
    /**
     * Queries delegated staking activities
     *
     * @param delegatorAddress Delegator address
     * @param poolAddress Pool address
     * @returns GetDelegatedStakingActivitiesQuery response type
     */
    getDelegatedStakingActivities(delegatorAddress: MaybeHexString, poolAddress: MaybeHexString): Promise<GetDelegatedStakingActivitiesQuery>;
    /**
     * Gets the count of token's activities
     *
     * @param tokenId Token ID
     * @returns GetTokenActivitiesCountQuery response type
     */
    getTokenActivitiesCount(tokenId: string): Promise<GetTokenActivitiesCountQuery>;
    /**
     * Queries token data
     *
     * @param tokenId Token ID address
     * @returns GetTokenDataQuery response type
     */
    getTokenData(tokenId: string, extraArgs?: {
        tokenStandard?: TokenStandard;
    }): Promise<GetTokenDataQuery>;
    /**
     * Queries token owners data. This query returns historical owners data
     * To fetch token v2 standard, pass in the optional `tokenStandard` parameter and
     * dont pass `propertyVersion` parameter (as propertyVersion only compatible with v1 standard)
     *
     * @param tokenId Token ID
     * @param propertyVersion Property version (optional) - only compatible with token v1 standard
     * @returns GetTokenOwnersDataQuery response type
     */
    getTokenOwnersData(tokenId: string, propertyVersion?: number, extraArgs?: {
        tokenStandard?: TokenStandard;
    }): Promise<GetTokenOwnersDataQuery>;
    /**
     * Queries token current owner data. This query returns the current token owner data.
     * To fetch token v2 standard, pass in the optional `tokenStandard` parameter and
     * dont pass `propertyVersion` parameter (as propertyVersion only compatible with v1 standard)
     *
     * @param tokenId Token ID
     * @param propertyVersion Property version (optional) - only compatible with token v1 standard
     * @returns GetTokenCurrentOwnerDataQuery response type
     */
    getTokenCurrentOwnerData(tokenId: string, propertyVersion?: number, extraArgs?: {
        tokenStandard?: TokenStandard;
    }): Promise<GetTokenCurrentOwnerDataQuery>;
    /**
     * Queries top user transactions
     *
     * @param limit
     * @returns GetTopUserTransactionsQuery response type
     */
    getTopUserTransactions(limit: number): Promise<GetTopUserTransactionsQuery>;
    /**
     * Queries top user transactions
     *
     * @returns GetUserTransactionsQuery response type
     */
    getUserTransactions(startVersion?: number, options?: PaginationArgs$1): Promise<GetUserTransactionsQuery>;
    /**
     * Queries current number of delegators in a pool
     *
     * @returns GetNumberOfDelegatorsQuery response type
     */
    getNumberOfDelegators(poolAddress: MaybeHexString): Promise<GetNumberOfDelegatorsQuery>;
    /**
     * Queries account's current owned tokens.
     * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.
     * If you want to get only the token from a specific standrd, you can pass an optional tokenStandard param
     * @example An example of how to pass a specific token standard
     * ```
     * {
     *    tokenStandard:"v2"
     * }
     * ```
     * @param ownerAddress The token owner address we want to get the tokens for
     * @returns GetOwnedTokensQuery response type
     */
    getOwnedTokens(ownerAddress: MaybeHexString, extraArgs?: {
        tokenStandard?: TokenStandard;
        options?: PaginationArgs$1;
    }): Promise<GetOwnedTokensQuery>;
    /**
     * Queries all tokens of a specific collection that an account owns by the collection address
     *
     * @param ownerAddress owner address that owns the tokens
     * @param collectionAddress the collection address
     * @returns GetTokenOwnedFromCollectionQuery response type
     */
    getTokenOwnedFromCollectionAddress(ownerAddress: MaybeHexString, collectionAddress: string, extraArgs?: {
        tokenStandard?: TokenStandard;
        options?: PaginationArgs$1;
    }): Promise<GetTokenOwnedFromCollectionQuery>;
    /**
     * Queries all tokens of a specific collection that an account owns by the collection name and collection
     * creator address
     *
     * @param ownerAddress owner address that owns the tokens
     * @param collectionName the collection name
     * @param creatorAddress the collection creator address
     * @returns GetTokenOwnedFromCollectionQuery response type
     */
    getTokenOwnedFromCollectionNameAndCreatorAddress(ownerAddress: MaybeHexString, collectionName: string, creatorAddress: MaybeHexString, extraArgs?: {
        tokenStandard?: TokenStandard;
        options?: PaginationArgs$1;
    }): Promise<GetTokenOwnedFromCollectionQuery>;
    /**
     * Queries data of a specific collection by the collection creator address and the collection name.
     *
     * if, for some reason, a creator account has 2 collections with the same name in v1 and v2,
     * can pass an optional `tokenStandard` parameter to query a specific standard
     *
     * @param creatorAddress the collection creator address
     * @param collectionName the collection name
     * @returns GetCollectionDataQuery response type
     */
    getCollectionData(creatorAddress: MaybeHexString, collectionName: string, extraArgs?: {
        tokenStandard?: TokenStandard;
        options?: PaginationArgs$1;
    }): Promise<GetCollectionDataQuery>;
    /**
     * Queries a collection address.
     *
     * @param creatorAddress the collection creator address
     * @param collectionName the collection name
     * @returns the collection address
     */
    getCollectionAddress(creatorAddress: MaybeHexString, collectionName: string, extraArgs?: {
        tokenStandard?: TokenStandard;
    }): Promise<string>;
    /**
     * Queries for all collections that an account has tokens for.
     *
     * @param ownerAddress the account address that owns the tokens
     * @returns GetCollectionsWithOwnedTokensQuery response type
     */
    getCollectionsWithOwnedTokens(ownerAddress: MaybeHexString, extraArgs?: {
        tokenStandard?: TokenStandard;
        options?: PaginationArgs$1;
    }): Promise<GetCollectionsWithOwnedTokensQuery>;
}

declare class AccountAddress {
    static readonly LENGTH: number;
    readonly address: Bytes;
    static CORE_CODE_ADDRESS: AccountAddress;
    constructor(address: Bytes);
    /**
     * Creates AccountAddress from a hex string.
     * @param addr Hex string can be with a prefix or without a prefix,
     *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.
     */
    static fromHex(addr: MaybeHexString): AccountAddress;
    /**
     * Checks if the string is a valid AccountAddress
     * @param addr Hex string can be with a prefix or without a prefix,
     *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.
     */
    static isValid(addr: MaybeHexString): boolean;
    /**
     * Return a hex string from account Address.
     */
    toHexString(): MaybeHexString;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): AccountAddress;
    /**
     * Standardizes an address to the format "0x" followed by 64 lowercase hexadecimal digits.
     */
    static standardizeAddress(address: string): string;
}

declare class Ed25519PublicKey {
    static readonly LENGTH: number;
    readonly value: Bytes;
    constructor(value: Bytes);
    toBytes(): Bytes;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Ed25519PublicKey;
}
declare class Ed25519Signature {
    readonly value: Bytes;
    static readonly LENGTH = 64;
    constructor(value: Bytes);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Ed25519Signature;
}

declare class MultiEd25519PublicKey {
    readonly public_keys: Seq<Ed25519PublicKey>;
    readonly threshold: Uint8;
    /**
     * Public key for a K-of-N multisig transaction. A K-of-N multisig transaction means that for such a
     * transaction to be executed, at least K out of the N authorized signers have signed the transaction
     * and passed the check conducted by the chain.
     *
     * @see {@link
     * https://aptos.dev/guides/creating-a-signed-transaction#multisignature-transactions | Creating a Signed Transaction}
     *
     * @param public_keys A list of public keys
     * @param threshold At least "threshold" signatures must be valid
     */
    constructor(public_keys: Seq<Ed25519PublicKey>, threshold: Uint8);
    /**
     * Converts a MultiEd25519PublicKey into bytes with: bytes = p1_bytes | ... | pn_bytes | threshold
     */
    toBytes(): Bytes;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiEd25519PublicKey;
}
declare class MultiEd25519Signature {
    readonly signatures: Seq<Ed25519Signature>;
    readonly bitmap: Uint8Array;
    static BITMAP_LEN: Uint8;
    /**
     * Signature for a K-of-N multisig transaction.
     *
     * @see {@link
     * https://aptos.dev/guides/creating-a-signed-transaction#multisignature-transactions | Creating a Signed Transaction}
     *
     * @param signatures A list of ed25519 signatures
     * @param bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth
     * signature should be provided in `signatures`. Bits are read from left to right
     */
    constructor(signatures: Seq<Ed25519Signature>, bitmap: Uint8Array);
    /**
     * Converts a MultiEd25519Signature into bytes with `bytes = s1_bytes | ... | sn_bytes | bitmap`
     */
    toBytes(): Bytes;
    /**
     * Helper method to create a bitmap out of the specified bit positions
     * @param bits The bitmap positions that should be set. A position starts at index 0.
     * Valid position should range between 0 and 31.
     * @example
     * Here's an example of valid `bits`
     * ```
     * [0, 2, 31]
     * ```
     * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.
     * The result bitmap should be 0b1010000000000000000000000000001
     *
     * @returns bitmap that is 32bit long
     */
    static createBitmap(bits: Seq<Uint8>): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiEd25519Signature;
}

declare abstract class TransactionAuthenticator {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): TransactionAuthenticator;
}
declare class TransactionAuthenticatorEd25519 extends TransactionAuthenticator {
    readonly public_key: Ed25519PublicKey;
    readonly signature: Ed25519Signature;
    /**
     * An authenticator for single signature.
     *
     * @param public_key Client's public key.
     * @param signature Signature of a raw transaction.
     * @see {@link https://aptos.dev/guides/creating-a-signed-transaction/ | Creating a Signed Transaction}
     * for details about generating a signature.
     */
    constructor(public_key: Ed25519PublicKey, signature: Ed25519Signature);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionAuthenticatorEd25519;
}
declare class TransactionAuthenticatorMultiEd25519 extends TransactionAuthenticator {
    readonly public_key: MultiEd25519PublicKey;
    readonly signature: MultiEd25519Signature;
    /**
     * An authenticator for multiple signatures.
     *
     * @param public_key
     * @param signature
     *
     */
    constructor(public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionAuthenticatorMultiEd25519;
}
declare class TransactionAuthenticatorMultiAgent extends TransactionAuthenticator {
    readonly sender: AccountAuthenticator;
    readonly secondary_signer_addresses: Seq<AccountAddress>;
    readonly secondary_signers: Seq<AccountAuthenticator>;
    constructor(sender: AccountAuthenticator, secondary_signer_addresses: Seq<AccountAddress>, secondary_signers: Seq<AccountAuthenticator>);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionAuthenticatorMultiAgent;
}
declare class TransactionAuthenticatorFeePayer extends TransactionAuthenticator {
    readonly sender: AccountAuthenticator;
    readonly secondary_signer_addresses: Seq<AccountAddress>;
    readonly secondary_signers: Seq<AccountAuthenticator>;
    readonly fee_payer: {
        address: AccountAddress;
        authenticator: AccountAuthenticator;
    };
    constructor(sender: AccountAuthenticator, secondary_signer_addresses: Seq<AccountAddress>, secondary_signers: Seq<AccountAuthenticator>, fee_payer: {
        address: AccountAddress;
        authenticator: AccountAuthenticator;
    });
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionAuthenticatorMultiAgent;
}
declare abstract class AccountAuthenticator {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): AccountAuthenticator;
}
declare class AccountAuthenticatorEd25519 extends AccountAuthenticator {
    readonly public_key: Ed25519PublicKey;
    readonly signature: Ed25519Signature;
    constructor(public_key: Ed25519PublicKey, signature: Ed25519Signature);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): AccountAuthenticatorEd25519;
}
declare class AccountAuthenticatorMultiEd25519 extends AccountAuthenticator {
    readonly public_key: MultiEd25519PublicKey;
    readonly signature: MultiEd25519Signature;
    constructor(public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): AccountAuthenticatorMultiEd25519;
}

declare class Identifier {
    value: string;
    constructor(value: string);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Identifier;
}

declare abstract class TypeTag {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): TypeTag;
}
declare class TypeTagBool extends TypeTag {
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagBool;
}
declare class TypeTagU8 extends TypeTag {
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU8;
}
declare class TypeTagU16 extends TypeTag {
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU16;
}
declare class TypeTagU32 extends TypeTag {
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU32;
}
declare class TypeTagU64 extends TypeTag {
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU64;
}
declare class TypeTagU128 extends TypeTag {
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU128;
}
declare class TypeTagU256 extends TypeTag {
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU256;
}
declare class TypeTagAddress extends TypeTag {
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagAddress;
}
declare class TypeTagSigner extends TypeTag {
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagSigner;
}
declare class TypeTagVector extends TypeTag {
    readonly value: TypeTag;
    constructor(value: TypeTag);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TypeTagVector;
}
declare class TypeTagStruct extends TypeTag {
    readonly value: StructTag;
    constructor(value: StructTag);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TypeTagStruct;
    isStringTypeTag(): boolean;
}
declare class StructTag {
    readonly address: AccountAddress;
    readonly module_name: Identifier;
    readonly name: Identifier;
    readonly type_args: Seq<TypeTag>;
    constructor(address: AccountAddress, module_name: Identifier, name: Identifier, type_args: Seq<TypeTag>);
    /**
     * Converts a string literal to a StructTag
     * @param structTag String literal in format "AcountAddress::module_name::ResourceName",
     *   e.g. "0x1::aptos_coin::AptosCoin"
     * @returns
     */
    static fromString(structTag: string): StructTag;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): StructTag;
}
declare const stringStructTag: StructTag;
declare function optionStructTag(typeArg: TypeTag): StructTag;
declare function objectStructTag(typeArg: TypeTag): StructTag;
/**
 * Parser to parse a type tag string
 */
declare class TypeTagParser {
    private readonly tokens;
    private readonly typeTags;
    constructor(tagStr: string, typeTags?: string[]);
    private consume;
    /**
     * Consumes all of an unused generic field, mostly applicable to object
     *
     * Note: This is recursive.  it can be problematic if there's bad input
     * @private
     */
    private consumeWholeGeneric;
    private parseCommaList;
    parseTypeTag(): TypeTag;
}
declare class TypeTagParserError extends Error {
    constructor(message: string);
}

declare class RawTransaction {
    readonly sender: AccountAddress;
    readonly sequence_number: Uint64;
    readonly payload: TransactionPayload;
    readonly max_gas_amount: Uint64;
    readonly gas_unit_price: Uint64;
    readonly expiration_timestamp_secs: Uint64;
    readonly chain_id: ChainId;
    /**
     * RawTransactions contain the metadata and payloads that can be submitted to Aptos chain for execution.
     * RawTransactions must be signed before Aptos chain can execute them.
     *
     * @param sender Account address of the sender.
     * @param sequence_number Sequence number of this transaction. This must match the sequence number stored in
     *   the sender's account at the time the transaction executes.
     * @param payload Instructions for the Aptos Blockchain, including publishing a module,
     *   execute a entry function or execute a script payload.
     * @param max_gas_amount Maximum total gas to spend for this transaction. The account must have more
     *   than this gas or the transaction will be discarded during validation.
     * @param gas_unit_price Price to be paid per gas unit.
     * @param expiration_timestamp_secs The blockchain timestamp at which the blockchain would discard this transaction.
     * @param chain_id The chain ID of the blockchain that this transaction is intended to be run on.
     */
    constructor(sender: AccountAddress, sequence_number: Uint64, payload: TransactionPayload, max_gas_amount: Uint64, gas_unit_price: Uint64, expiration_timestamp_secs: Uint64, chain_id: ChainId);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): RawTransaction;
}
declare class Script {
    readonly code: Bytes;
    readonly ty_args: Seq<TypeTag>;
    readonly args: Seq<TransactionArgument>;
    /**
     * Scripts contain the Move bytecodes payload that can be submitted to Aptos chain for execution.
     * @param code Move bytecode
     * @param ty_args Type arguments that bytecode requires.
     *
     * @example
     * A coin transfer function has one type argument "CoinType".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
     * ```
     * @param args Arugments to bytecode function.
     *
     * @example
     * A coin transfer function has three arugments "from", "to" and "amount".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
     * ```
     */
    constructor(code: Bytes, ty_args: Seq<TypeTag>, args: Seq<TransactionArgument>);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Script;
}
declare class EntryFunction {
    readonly module_name: ModuleId;
    readonly function_name: Identifier;
    readonly ty_args: Seq<TypeTag>;
    readonly args: Seq<Bytes>;
    /**
     * Contains the payload to run a function within a module.
     * @param module_name Fully qualified module name. ModuleId consists of account address and module name.
     * @param function_name The function to run.
     * @param ty_args Type arguments that move function requires.
     *
     * @example
     * A coin transfer function has one type argument "CoinType".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
     * ```
     * @param args Arugments to the move function.
     *
     * @example
     * A coin transfer function has three arugments "from", "to" and "amount".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
     * ```
     */
    constructor(module_name: ModuleId, function_name: Identifier, ty_args: Seq<TypeTag>, args: Seq<Bytes>);
    /**
     *
     * @param module Fully qualified module name in format "AccountAddress::module_name" e.g. "0x1::coin"
     * @param func Function name
     * @param ty_args Type arguments that move function requires.
     *
     * @example
     * A coin transfer function has one type argument "CoinType".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
     * ```
     * @param args Arugments to the move function.
     *
     * @example
     * A coin transfer function has three arugments "from", "to" and "amount".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
     * ```
     * @returns
     */
    static natural(module: string, func: string, ty_args: Seq<TypeTag>, args: Seq<Bytes>): EntryFunction;
    /**
     * `natual` is deprecated, please use `natural`
     *
     * @deprecated.
     */
    static natual(module: string, func: string, ty_args: Seq<TypeTag>, args: Seq<Bytes>): EntryFunction;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): EntryFunction;
}
declare class MultiSigTransactionPayload {
    readonly transaction_payload: EntryFunction;
    /**
     * Contains the payload to run a multisig account transaction.
     * @param transaction_payload The payload of the multisig transaction. This can only be EntryFunction for now but
     * Script might be supported in the future.
     */
    constructor(transaction_payload: EntryFunction);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiSigTransactionPayload;
}
declare class MultiSig {
    readonly multisig_address: AccountAddress;
    readonly transaction_payload?: MultiSigTransactionPayload | undefined;
    /**
     * Contains the payload to run a multisig account transaction.
     * @param multisig_address The multisig account address the transaction will be executed as.
     * @param transaction_payload The payload of the multisig transaction. This is optional when executing a multisig
     *  transaction whose payload is already stored on chain.
     */
    constructor(multisig_address: AccountAddress, transaction_payload?: MultiSigTransactionPayload | undefined);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiSig;
}
declare class Module {
    readonly code: Bytes;
    /**
     * Contains the bytecode of a Move module that can be published to the Aptos chain.
     * @param code Move bytecode of a module.
     */
    constructor(code: Bytes);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Module;
}
declare class ModuleId {
    readonly address: AccountAddress;
    readonly name: Identifier;
    /**
     * Full name of a module.
     * @param address The account address.
     * @param name The name of the module under the account at "address".
     */
    constructor(address: AccountAddress, name: Identifier);
    /**
     * Converts a string literal to a ModuleId
     * @param moduleId String literal in format "AccountAddress::module_name", e.g. "0x1::coin"
     * @returns
     */
    static fromStr(moduleId: string): ModuleId;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): ModuleId;
}
declare class ChangeSet {
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): ChangeSet;
}
declare class WriteSet {
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): WriteSet;
}
declare class SignedTransaction {
    readonly raw_txn: RawTransaction;
    readonly authenticator: TransactionAuthenticator;
    /**
     * A SignedTransaction consists of a raw transaction and an authenticator. The authenticator
     * contains a client's public key and the signature of the raw transaction.
     *
     * @see {@link https://aptos.dev/guides/creating-a-signed-transaction/ | Creating a Signed Transaction}
     *
     * @param raw_txn
     * @param authenticator Contains a client's public key and the signature of the raw transaction.
     *   Authenticator has 3 flavors: single signature, multi-signature and multi-agent.
     *   @see authenticator.ts for details.
     */
    constructor(raw_txn: RawTransaction, authenticator: TransactionAuthenticator);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): SignedTransaction;
}
declare abstract class RawTransactionWithData {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): RawTransactionWithData;
}
declare class MultiAgentRawTransaction extends RawTransactionWithData {
    readonly raw_txn: RawTransaction;
    readonly secondary_signer_addresses: Seq<AccountAddress>;
    constructor(raw_txn: RawTransaction, secondary_signer_addresses: Seq<AccountAddress>);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): MultiAgentRawTransaction;
}
declare class FeePayerRawTransaction extends RawTransactionWithData {
    readonly raw_txn: RawTransaction;
    readonly secondary_signer_addresses: Seq<AccountAddress>;
    readonly fee_payer_address: AccountAddress;
    constructor(raw_txn: RawTransaction, secondary_signer_addresses: Seq<AccountAddress>, fee_payer_address: AccountAddress);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): FeePayerRawTransaction;
}
declare abstract class TransactionPayload {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): TransactionPayload;
}
declare class TransactionPayloadScript extends TransactionPayload {
    readonly value: Script;
    constructor(value: Script);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionPayloadScript;
}
declare class TransactionPayloadEntryFunction extends TransactionPayload {
    readonly value: EntryFunction;
    constructor(value: EntryFunction);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionPayloadEntryFunction;
}
declare class TransactionPayloadMultisig extends TransactionPayload {
    readonly value: MultiSig;
    constructor(value: MultiSig);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionPayloadMultisig;
}
declare class ChainId {
    readonly value: Uint8;
    constructor(value: Uint8);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): ChainId;
}
declare abstract class TransactionArgument {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): TransactionArgument;
}
declare class TransactionArgumentU8 extends TransactionArgument {
    readonly value: Uint8;
    constructor(value: Uint8);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionArgumentU8;
}
declare class TransactionArgumentU16 extends TransactionArgument {
    readonly value: Uint16;
    constructor(value: Uint16);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionArgumentU16;
}
declare class TransactionArgumentU32 extends TransactionArgument {
    readonly value: Uint16;
    constructor(value: Uint16);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionArgumentU32;
}
declare class TransactionArgumentU64 extends TransactionArgument {
    readonly value: Uint64;
    constructor(value: Uint64);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionArgumentU64;
}
declare class TransactionArgumentU128 extends TransactionArgument {
    readonly value: Uint128;
    constructor(value: Uint128);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionArgumentU128;
}
declare class TransactionArgumentU256 extends TransactionArgument {
    readonly value: Uint256;
    constructor(value: Uint256);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionArgumentU256;
}
declare class TransactionArgumentAddress extends TransactionArgument {
    readonly value: AccountAddress;
    constructor(value: AccountAddress);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionArgumentAddress;
}
declare class TransactionArgumentU8Vector extends TransactionArgument {
    readonly value: Bytes;
    constructor(value: Bytes);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionArgumentU8Vector;
}
declare class TransactionArgumentBool extends TransactionArgument {
    readonly value: boolean;
    constructor(value: boolean);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionArgumentBool;
}
declare abstract class Transaction {
    abstract serialize(serializer: Serializer): void;
    abstract hash(): Bytes;
    getHashSalt(): Bytes;
    static deserialize(deserializer: Deserializer): Transaction;
}
declare class UserTransaction extends Transaction {
    readonly value: SignedTransaction;
    constructor(value: SignedTransaction);
    hash(): Bytes;
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): UserTransaction;
}

declare class TypeArgumentABI {
    readonly name: string;
    /**
     * Constructs a TypeArgumentABI instance.
     * @param name
     */
    constructor(name: string);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): TypeArgumentABI;
}
declare class ArgumentABI {
    readonly name: string;
    readonly type_tag: TypeTag;
    /**
     * Constructs an ArgumentABI instance.
     * @param name
     * @param type_tag
     */
    constructor(name: string, type_tag: TypeTag);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): ArgumentABI;
}
declare abstract class ScriptABI {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): ScriptABI;
}
declare class TransactionScriptABI extends ScriptABI {
    readonly name: string;
    readonly doc: string;
    readonly code: Bytes;
    readonly ty_args: Seq<TypeArgumentABI>;
    readonly args: Seq<ArgumentABI>;
    /**
     * Constructs a TransactionScriptABI instance.
     * @param name Entry function name
     * @param doc
     * @param code
     * @param ty_args
     * @param args
     */
    constructor(name: string, doc: string, code: Bytes, ty_args: Seq<TypeArgumentABI>, args: Seq<ArgumentABI>);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionScriptABI;
}
declare class EntryFunctionABI extends ScriptABI {
    readonly name: string;
    readonly module_name: ModuleId;
    readonly doc: string;
    readonly ty_args: Seq<TypeArgumentABI>;
    readonly args: Seq<ArgumentABI>;
    /**
     * Constructs a EntryFunctionABI instance
     * @param name
     * @param module_name Fully qualified module id
     * @param doc
     * @param ty_args
     * @param args
     */
    constructor(name: string, module_name: ModuleId, doc: string, ty_args: Seq<TypeArgumentABI>, args: Seq<ArgumentABI>);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): EntryFunctionABI;
}

/**
 * Each account stores an authentication key. Authentication key enables account owners to rotate
 * their private key(s) associated with the account without changing the address that hosts their account.
 * @see {@link * https://aptos.dev/concepts/accounts | Account Basics}
 *
 * Account addresses can be derived from AuthenticationKey
 */
declare class AuthenticationKey {
    static readonly LENGTH: number;
    static readonly MULTI_ED25519_SCHEME: number;
    static readonly ED25519_SCHEME: number;
    static readonly DERIVE_RESOURCE_ACCOUNT_SCHEME: number;
    readonly bytes: Bytes;
    constructor(bytes: Bytes);
    /**
     * Converts a K-of-N MultiEd25519PublicKey to AuthenticationKey with:
     * `auth_key = sha3-256(p_1 | … | p_n | K | 0x01)`. `K` represents the K-of-N required for
     * authenticating the transaction. `0x01` is the 1-byte scheme for multisig.
     */
    static fromMultiEd25519PublicKey(publicKey: MultiEd25519PublicKey): AuthenticationKey;
    static fromEd25519PublicKey(publicKey: Ed25519PublicKey): AuthenticationKey;
    /**
     * Derives an account address from AuthenticationKey. Since current AccountAddress is 32 bytes,
     * AuthenticationKey bytes are directly translated to AccountAddress.
     */
    derivedAddress(): HexString;
}

declare class RotationProofChallenge {
    readonly accountAddress: AccountAddress;
    readonly moduleName: string;
    readonly structName: string;
    readonly sequenceNumber: number | bigint;
    readonly originator: AccountAddress;
    readonly currentAuthKey: AccountAddress;
    readonly newPublicKey: Uint8Array;
    constructor(accountAddress: AccountAddress, moduleName: string, structName: string, sequenceNumber: number | bigint, originator: AccountAddress, currentAuthKey: AccountAddress, newPublicKey: Uint8Array);
    serialize(serializer: Serializer): void;
}

declare type SigningMessage = Uint8Array;

type index_SigningMessage = SigningMessage;
type index_TypeArgumentABI = TypeArgumentABI;
declare const index_TypeArgumentABI: typeof TypeArgumentABI;
type index_ArgumentABI = ArgumentABI;
declare const index_ArgumentABI: typeof ArgumentABI;
type index_ScriptABI = ScriptABI;
declare const index_ScriptABI: typeof ScriptABI;
type index_TransactionScriptABI = TransactionScriptABI;
declare const index_TransactionScriptABI: typeof TransactionScriptABI;
type index_EntryFunctionABI = EntryFunctionABI;
declare const index_EntryFunctionABI: typeof EntryFunctionABI;
type index_AccountAddress = AccountAddress;
declare const index_AccountAddress: typeof AccountAddress;
type index_TransactionAuthenticator = TransactionAuthenticator;
declare const index_TransactionAuthenticator: typeof TransactionAuthenticator;
type index_TransactionAuthenticatorEd25519 = TransactionAuthenticatorEd25519;
declare const index_TransactionAuthenticatorEd25519: typeof TransactionAuthenticatorEd25519;
type index_TransactionAuthenticatorMultiEd25519 = TransactionAuthenticatorMultiEd25519;
declare const index_TransactionAuthenticatorMultiEd25519: typeof TransactionAuthenticatorMultiEd25519;
type index_TransactionAuthenticatorMultiAgent = TransactionAuthenticatorMultiAgent;
declare const index_TransactionAuthenticatorMultiAgent: typeof TransactionAuthenticatorMultiAgent;
type index_TransactionAuthenticatorFeePayer = TransactionAuthenticatorFeePayer;
declare const index_TransactionAuthenticatorFeePayer: typeof TransactionAuthenticatorFeePayer;
type index_AccountAuthenticator = AccountAuthenticator;
declare const index_AccountAuthenticator: typeof AccountAuthenticator;
type index_AccountAuthenticatorEd25519 = AccountAuthenticatorEd25519;
declare const index_AccountAuthenticatorEd25519: typeof AccountAuthenticatorEd25519;
type index_AccountAuthenticatorMultiEd25519 = AccountAuthenticatorMultiEd25519;
declare const index_AccountAuthenticatorMultiEd25519: typeof AccountAuthenticatorMultiEd25519;
type index_RawTransaction = RawTransaction;
declare const index_RawTransaction: typeof RawTransaction;
type index_Script = Script;
declare const index_Script: typeof Script;
type index_EntryFunction = EntryFunction;
declare const index_EntryFunction: typeof EntryFunction;
type index_MultiSigTransactionPayload = MultiSigTransactionPayload;
declare const index_MultiSigTransactionPayload: typeof MultiSigTransactionPayload;
type index_MultiSig = MultiSig;
declare const index_MultiSig: typeof MultiSig;
type index_Module = Module;
declare const index_Module: typeof Module;
type index_ModuleId = ModuleId;
declare const index_ModuleId: typeof ModuleId;
type index_ChangeSet = ChangeSet;
declare const index_ChangeSet: typeof ChangeSet;
type index_WriteSet = WriteSet;
declare const index_WriteSet: typeof WriteSet;
type index_SignedTransaction = SignedTransaction;
declare const index_SignedTransaction: typeof SignedTransaction;
type index_RawTransactionWithData = RawTransactionWithData;
declare const index_RawTransactionWithData: typeof RawTransactionWithData;
type index_MultiAgentRawTransaction = MultiAgentRawTransaction;
declare const index_MultiAgentRawTransaction: typeof MultiAgentRawTransaction;
type index_FeePayerRawTransaction = FeePayerRawTransaction;
declare const index_FeePayerRawTransaction: typeof FeePayerRawTransaction;
type index_TransactionPayload = TransactionPayload;
declare const index_TransactionPayload: typeof TransactionPayload;
type index_TransactionPayloadScript = TransactionPayloadScript;
declare const index_TransactionPayloadScript: typeof TransactionPayloadScript;
type index_TransactionPayloadEntryFunction = TransactionPayloadEntryFunction;
declare const index_TransactionPayloadEntryFunction: typeof TransactionPayloadEntryFunction;
type index_TransactionPayloadMultisig = TransactionPayloadMultisig;
declare const index_TransactionPayloadMultisig: typeof TransactionPayloadMultisig;
type index_ChainId = ChainId;
declare const index_ChainId: typeof ChainId;
type index_TransactionArgument = TransactionArgument;
declare const index_TransactionArgument: typeof TransactionArgument;
type index_TransactionArgumentU8 = TransactionArgumentU8;
declare const index_TransactionArgumentU8: typeof TransactionArgumentU8;
type index_TransactionArgumentU16 = TransactionArgumentU16;
declare const index_TransactionArgumentU16: typeof TransactionArgumentU16;
type index_TransactionArgumentU32 = TransactionArgumentU32;
declare const index_TransactionArgumentU32: typeof TransactionArgumentU32;
type index_TransactionArgumentU64 = TransactionArgumentU64;
declare const index_TransactionArgumentU64: typeof TransactionArgumentU64;
type index_TransactionArgumentU128 = TransactionArgumentU128;
declare const index_TransactionArgumentU128: typeof TransactionArgumentU128;
type index_TransactionArgumentU256 = TransactionArgumentU256;
declare const index_TransactionArgumentU256: typeof TransactionArgumentU256;
type index_TransactionArgumentAddress = TransactionArgumentAddress;
declare const index_TransactionArgumentAddress: typeof TransactionArgumentAddress;
type index_TransactionArgumentU8Vector = TransactionArgumentU8Vector;
declare const index_TransactionArgumentU8Vector: typeof TransactionArgumentU8Vector;
type index_TransactionArgumentBool = TransactionArgumentBool;
declare const index_TransactionArgumentBool: typeof TransactionArgumentBool;
type index_Transaction = Transaction;
declare const index_Transaction: typeof Transaction;
type index_UserTransaction = UserTransaction;
declare const index_UserTransaction: typeof UserTransaction;
type index_TypeTag = TypeTag;
declare const index_TypeTag: typeof TypeTag;
type index_TypeTagBool = TypeTagBool;
declare const index_TypeTagBool: typeof TypeTagBool;
type index_TypeTagU8 = TypeTagU8;
declare const index_TypeTagU8: typeof TypeTagU8;
type index_TypeTagU16 = TypeTagU16;
declare const index_TypeTagU16: typeof TypeTagU16;
type index_TypeTagU32 = TypeTagU32;
declare const index_TypeTagU32: typeof TypeTagU32;
type index_TypeTagU64 = TypeTagU64;
declare const index_TypeTagU64: typeof TypeTagU64;
type index_TypeTagU128 = TypeTagU128;
declare const index_TypeTagU128: typeof TypeTagU128;
type index_TypeTagU256 = TypeTagU256;
declare const index_TypeTagU256: typeof TypeTagU256;
type index_TypeTagAddress = TypeTagAddress;
declare const index_TypeTagAddress: typeof TypeTagAddress;
type index_TypeTagSigner = TypeTagSigner;
declare const index_TypeTagSigner: typeof TypeTagSigner;
type index_TypeTagVector = TypeTagVector;
declare const index_TypeTagVector: typeof TypeTagVector;
type index_TypeTagStruct = TypeTagStruct;
declare const index_TypeTagStruct: typeof TypeTagStruct;
type index_StructTag = StructTag;
declare const index_StructTag: typeof StructTag;
declare const index_stringStructTag: typeof stringStructTag;
declare const index_optionStructTag: typeof optionStructTag;
declare const index_objectStructTag: typeof objectStructTag;
type index_TypeTagParser = TypeTagParser;
declare const index_TypeTagParser: typeof TypeTagParser;
type index_TypeTagParserError = TypeTagParserError;
declare const index_TypeTagParserError: typeof TypeTagParserError;
type index_Identifier = Identifier;
declare const index_Identifier: typeof Identifier;
type index_Ed25519PublicKey = Ed25519PublicKey;
declare const index_Ed25519PublicKey: typeof Ed25519PublicKey;
type index_Ed25519Signature = Ed25519Signature;
declare const index_Ed25519Signature: typeof Ed25519Signature;
type index_MultiEd25519PublicKey = MultiEd25519PublicKey;
declare const index_MultiEd25519PublicKey: typeof MultiEd25519PublicKey;
type index_MultiEd25519Signature = MultiEd25519Signature;
declare const index_MultiEd25519Signature: typeof MultiEd25519Signature;
type index_AuthenticationKey = AuthenticationKey;
declare const index_AuthenticationKey: typeof AuthenticationKey;
type index_RotationProofChallenge = RotationProofChallenge;
declare const index_RotationProofChallenge: typeof RotationProofChallenge;
declare namespace index {
  export {
    index_SigningMessage as SigningMessage,
    index_TypeArgumentABI as TypeArgumentABI,
    index_ArgumentABI as ArgumentABI,
    index_ScriptABI as ScriptABI,
    index_TransactionScriptABI as TransactionScriptABI,
    index_EntryFunctionABI as EntryFunctionABI,
    index_AccountAddress as AccountAddress,
    index_TransactionAuthenticator as TransactionAuthenticator,
    index_TransactionAuthenticatorEd25519 as TransactionAuthenticatorEd25519,
    index_TransactionAuthenticatorMultiEd25519 as TransactionAuthenticatorMultiEd25519,
    index_TransactionAuthenticatorMultiAgent as TransactionAuthenticatorMultiAgent,
    index_TransactionAuthenticatorFeePayer as TransactionAuthenticatorFeePayer,
    index_AccountAuthenticator as AccountAuthenticator,
    index_AccountAuthenticatorEd25519 as AccountAuthenticatorEd25519,
    index_AccountAuthenticatorMultiEd25519 as AccountAuthenticatorMultiEd25519,
    index_RawTransaction as RawTransaction,
    index_Script as Script,
    index_EntryFunction as EntryFunction,
    index_MultiSigTransactionPayload as MultiSigTransactionPayload,
    index_MultiSig as MultiSig,
    index_Module as Module,
    index_ModuleId as ModuleId,
    index_ChangeSet as ChangeSet,
    index_WriteSet as WriteSet,
    index_SignedTransaction as SignedTransaction,
    index_RawTransactionWithData as RawTransactionWithData,
    index_MultiAgentRawTransaction as MultiAgentRawTransaction,
    index_FeePayerRawTransaction as FeePayerRawTransaction,
    index_TransactionPayload as TransactionPayload,
    index_TransactionPayloadScript as TransactionPayloadScript,
    index_TransactionPayloadEntryFunction as TransactionPayloadEntryFunction,
    index_TransactionPayloadMultisig as TransactionPayloadMultisig,
    index_ChainId as ChainId,
    index_TransactionArgument as TransactionArgument,
    index_TransactionArgumentU8 as TransactionArgumentU8,
    index_TransactionArgumentU16 as TransactionArgumentU16,
    index_TransactionArgumentU32 as TransactionArgumentU32,
    index_TransactionArgumentU64 as TransactionArgumentU64,
    index_TransactionArgumentU128 as TransactionArgumentU128,
    index_TransactionArgumentU256 as TransactionArgumentU256,
    index_TransactionArgumentAddress as TransactionArgumentAddress,
    index_TransactionArgumentU8Vector as TransactionArgumentU8Vector,
    index_TransactionArgumentBool as TransactionArgumentBool,
    index_Transaction as Transaction,
    index_UserTransaction as UserTransaction,
    index_TypeTag as TypeTag,
    index_TypeTagBool as TypeTagBool,
    index_TypeTagU8 as TypeTagU8,
    index_TypeTagU16 as TypeTagU16,
    index_TypeTagU32 as TypeTagU32,
    index_TypeTagU64 as TypeTagU64,
    index_TypeTagU128 as TypeTagU128,
    index_TypeTagU256 as TypeTagU256,
    index_TypeTagAddress as TypeTagAddress,
    index_TypeTagSigner as TypeTagSigner,
    index_TypeTagVector as TypeTagVector,
    index_TypeTagStruct as TypeTagStruct,
    index_StructTag as StructTag,
    index_stringStructTag as stringStructTag,
    index_optionStructTag as optionStructTag,
    index_objectStructTag as objectStructTag,
    index_TypeTagParser as TypeTagParser,
    index_TypeTagParserError as TypeTagParserError,
    index_Identifier as Identifier,
    index_Ed25519PublicKey as Ed25519PublicKey,
    index_Ed25519Signature as Ed25519Signature,
    index_MultiEd25519PublicKey as MultiEd25519PublicKey,
    index_MultiEd25519Signature as MultiEd25519Signature,
    index_AuthenticationKey as AuthenticationKey,
    index_RotationProofChallenge as RotationProofChallenge,
  };
}

declare type AnyRawTransaction = RawTransaction | MultiAgentRawTransaction | FeePayerRawTransaction;
/**
 * Function that takes in a Signing Message (serialized raw transaction)
 *  and returns a signature
 */
declare type SigningFn = (txn: SigningMessage) => Ed25519Signature | MultiEd25519Signature;
declare class TransactionBuilder<F extends SigningFn> {
    readonly rawTxnBuilder?: TransactionBuilderABI | undefined;
    protected readonly signingFunction: F;
    constructor(signingFunction: F, rawTxnBuilder?: TransactionBuilderABI | undefined);
    /**
     * Builds a RawTransaction. Relays the call to TransactionBuilderABI.build
     * @param func
     * @param ty_tags
     * @param args
     */
    build(func: string, ty_tags: string[], args: any[]): RawTransaction;
    /** Generates a Signing Message out of a raw transaction. */
    static getSigningMessage(rawTxn: AnyRawTransaction): SigningMessage;
}
/**
 * Provides signing method for signing a raw transaction with single public key.
 */
declare class TransactionBuilderEd25519 extends TransactionBuilder<SigningFn> {
    private readonly publicKey;
    constructor(signingFunction: SigningFn, publicKey: Uint8Array, rawTxnBuilder?: TransactionBuilderABI);
    rawToSigned(rawTxn: RawTransaction): SignedTransaction;
    /** Signs a raw transaction and returns a bcs serialized transaction. */
    sign(rawTxn: RawTransaction): Bytes;
}
/**
 * Provides signing method for signing a raw transaction with multisig public key.
 */
declare class TransactionBuilderMultiEd25519 extends TransactionBuilder<SigningFn> {
    private readonly publicKey;
    constructor(signingFunction: SigningFn, publicKey: MultiEd25519PublicKey);
    rawToSigned(rawTxn: RawTransaction): SignedTransaction;
    /** Signs a raw transaction and returns a bcs serialized transaction. */
    sign(rawTxn: RawTransaction): Bytes;
}
/**
 * Config for creating raw transactions.
 */
interface ABIBuilderConfig {
    sender: MaybeHexString | AccountAddress;
    sequenceNumber: Uint64 | string;
    gasUnitPrice: Uint64 | string;
    maxGasAmount?: Uint64 | string;
    expSecFromNow?: number | string;
    chainId: Uint8 | string;
}
/**
 * Builds raw transactions based on ABI
 */
declare class TransactionBuilderABI {
    private readonly abiMap;
    private readonly builderConfig;
    /**
     * Constructs a TransactionBuilderABI instance
     * @param abis List of binary ABIs.
     * @param builderConfig Configs for creating a raw transaction.
     */
    constructor(abis: Bytes[], builderConfig?: ABIBuilderConfig);
    private static toBCSArgs;
    private static toTransactionArguments;
    setSequenceNumber(seqNumber: Uint64 | string): void;
    /**
     * Builds a TransactionPayload. For dApps, chain ID and account sequence numbers are only known to the wallet.
     * Instead of building a RawTransaction (requires chainID and sequenceNumber), dApps can build a TransactionPayload
     * and pass the payload to the wallet for signing and sending.
     * @param func Fully qualified func names, e.g. 0x1::aptos_account::transfer
     * @param ty_tags TypeTag strings
     * @param args Function arguments
     * @returns TransactionPayload
     */
    buildTransactionPayload(func: string, ty_tags: string[], args: any[]): TransactionPayload;
    /**
     * Builds a RawTransaction
     * @param func Fully qualified func names, e.g. 0x1::aptos_account::transfer
     * @param ty_tags TypeTag strings.
     * @example Below are valid value examples
     * ```
     * // Structs are in format `AccountAddress::ModuleName::StructName`
     * 0x1::aptos_coin::AptosCoin
     * // Vectors are in format `vector<other_tag_string>`
     * vector<0x1::aptos_coin::AptosCoin>
     * bool
     * u8
     * u16
     * u32
     * u64
     * u128
     * u256
     * address
     * ```
     * @param args Function arguments
     * @returns RawTransaction
     */
    build(func: string, ty_tags: string[], args: any[]): RawTransaction;
}
declare type RemoteABIBuilderConfig = Partial<Omit<ABIBuilderConfig, "sender">> & {
    sender: MaybeHexString | AccountAddress;
};
interface AptosClientInterface {
    getAccountModules: (accountAddress: MaybeHexString) => Promise<MoveModuleBytecode[]>;
    getAccount: (accountAddress: MaybeHexString) => Promise<AccountData>;
    getChainId: () => Promise<number>;
    estimateGasPrice: () => Promise<GasEstimation>;
}
/**
 * This transaction builder downloads JSON ABIs from the fullnodes.
 * It then translates the JSON ABIs to the format that is accepted by TransactionBuilderABI
 */
declare class TransactionBuilderRemoteABI {
    private readonly aptosClient;
    private readonly builderConfig;
    constructor(aptosClient: AptosClientInterface, builderConfig: RemoteABIBuilderConfig);
    fetchABI(addr: string): Promise<Map<string, MoveFunction & {
        fullName: string;
    }>>;
    /**
     * Builds a raw transaction. Only support script function a.k.a entry function payloads
     *
     * @param func fully qualified function name in format <address>::<module>::<function>, e.g. 0x1::coin::transfer
     * @param ty_tags
     * @param args
     * @returns RawTransaction
     */
    build(func: EntryFunctionId, ty_tags: MoveType[], args: any[]): Promise<RawTransaction>;
}

interface OptionalTransactionArgs {
    maxGasAmount?: Uint64;
    gasUnitPrice?: Uint64;
    expireTimestamp?: Uint64;
    providedSequenceNumber?: string | bigint;
}
interface PaginationArgs {
    start?: AnyNumber;
    limit?: number;
}
/**
 * Provides methods for retrieving data from Aptos node.
 * For more detailed API specification see {@link https://fullnode.devnet.aptoslabs.com/v1/spec}
 */
declare class AptosClient {
    readonly nodeUrl: string;
    readonly config: ClientConfig | undefined;
    /**
     * Build a client configured to connect to an Aptos node at the given URL.
     *
     * Note: If you forget to append `/v1` to the URL, the client constructor
     * will automatically append it. If you don't want this URL processing to
     * take place, set doNotFixNodeUrl to true.
     *
     * @param nodeUrl URL of the Aptos Node API endpoint.
     * @param config Additional configuration options for the generated Axios client.
     */
    constructor(nodeUrl: string, config?: ClientConfig, doNotFixNodeUrl?: boolean);
    /**
     * Queries an Aptos account by address
     * @param accountAddress Hex-encoded 32 byte Aptos account address
     * @returns Core account resource, used for identifying account and transaction execution
     * @example An example of the returned account
     * ```
     * {
     *    sequence_number: "1",
     *    authentication_key: "0x5307b5f4bc67829097a8ba9b43dba3b88261eeccd1f709d9bde240fc100fbb69"
     * }
     * ```
     */
    getAccount(accountAddress: MaybeHexString): Promise<AccountData>;
    /**
     * Queries transactions sent by given account
     * @param accountAddress Hex-encoded 32 byte Aptos account address
     * @param query Optional pagination object
     * @param query.start The sequence number of the start transaction of the page. Default is 0.
     * @param query.limit The max number of transactions should be returned for the page. Default is 25.
     * @returns An array of on-chain transactions, sent by account
     */
    getAccountTransactions(accountAddress: MaybeHexString, query?: PaginationArgs): Promise<Transaction$1[]>;
    /**
     * Queries modules associated with given account
     *
     * Note: In order to get all account modules, this function may call the API
     * multiple times as it paginates.
     *
     * @param accountAddress Hex-encoded 32 byte Aptos account address
     * @param query.ledgerVersion Specifies ledger version of transactions. By default latest version will be used
     * @returns Account modules array for a specific ledger version.
     * Module is represented by MoveModule interface. It contains module `bytecode` and `abi`,
     * which is JSON representation of a module. Account modules are cached by account address for 10 minutes
     * to prevent unnecessary API calls when fetching the same account modules
     */
    getAccountModules(accountAddress: MaybeHexString, query?: {
        ledgerVersion?: AnyNumber;
    }): Promise<MoveModuleBytecode[]>;
    /**
     * Queries module associated with given account by module name
     *
     * Note: In order to get all account resources, this function may call the API
     * multiple times as it paginates.
     *
     * @param accountAddress Hex-encoded 32 byte Aptos account address
     * @param moduleName The name of the module
     * @param query.ledgerVersion Specifies ledger version of transactions. By default latest version will be used
     * @returns Specified module.
     * Module is represented by MoveModule interface. It contains module `bytecode` and `abi`,
     * which JSON representation of a module
     */
    getAccountModule(accountAddress: MaybeHexString, moduleName: string, query?: {
        ledgerVersion?: AnyNumber;
    }): Promise<MoveModuleBytecode>;
    /**
     * Queries all resources associated with given account
     * @param accountAddress Hex-encoded 32 byte Aptos account address
     * @param query.ledgerVersion Specifies ledger version of transactions. By default latest version will be used
     * @returns Account resources for a specific ledger version
     */
    getAccountResources(accountAddress: MaybeHexString, query?: {
        ledgerVersion?: AnyNumber;
    }): Promise<MoveResource[]>;
    /**
     * Queries resource associated with given account by resource type
     * @param accountAddress Hex-encoded 32 byte Aptos account address
     * @param resourceType String representation of an on-chain Move struct type
     * @param query.ledgerVersion Specifies ledger version of transactions. By default latest version will be used
     * @returns Account resource of specified type and ledger version
     * @example An example of an account resource
     * ```
     * {
     *    type: "0x1::aptos_coin::AptosCoin",
     *    data: { value: 6 }
     * }
     * ```
     */
    getAccountResource(accountAddress: MaybeHexString, resourceType: MoveStructTag, query?: {
        ledgerVersion?: AnyNumber;
    }): Promise<MoveResource>;
    /** Generates a signed transaction that can be submitted to the chain for execution. */
    static generateBCSTransaction(accountFrom: AptosAccount, rawTxn: RawTransaction): Uint8Array;
    /**
     * Note: Unless you have a specific reason for using this, it'll probably be simpler
     * to use `simulateTransaction`.
     *
     * Generates a BCS transaction that can be submitted to the chain for simulation.
     *
     * @param accountFrom The account that will be used to send the transaction
     * for simulation.
     * @param rawTxn The raw transaction to be simulated, likely created by calling
     * the `generateTransaction` function.
     * @returns The BCS encoded signed transaction, which you should then pass into
     * the `submitBCSSimulation` function.
     */
    static generateBCSSimulation(accountFrom: AptosAccount, rawTxn: RawTransaction): Uint8Array;
    /** Generates an entry function transaction request that can be submitted to produce a raw transaction that
     * can be signed, which upon being signed can be submitted to the blockchain
     * This function fetches the remote ABI and uses it to serialized the data, therefore
     * users don't need to handle serialization by themselves.
     * @param sender Hex-encoded 32 byte Aptos account address of transaction sender
     * @param payload Entry function transaction payload type
     * @param options Options allow to overwrite default transaction options.
     * @returns A raw transaction object
     */
    generateTransaction(sender: MaybeHexString, payload: EntryFunctionPayload, options?: Partial<SubmitTransactionRequest>): Promise<RawTransaction>;
    /** Converts a transaction request produced by `generateTransaction` into a properly
     * signed transaction, which can then be submitted to the blockchain
     * @param accountFrom AptosAccount of transaction sender
     * @param rawTransaction A raw transaction generated by `generateTransaction` method
     * @returns A transaction, signed with sender account
     */
    signTransaction(accountFrom: AptosAccount, rawTransaction: RawTransaction): Promise<Uint8Array>;
    /**
     * Event types are globally identifiable by an account `address` and
     * monotonically increasing `creation_number`, one per event type emitted
     * to the given account. This API returns events corresponding to that
     * that event type.
     * @param address Hex-encoded 32 byte Aptos account, with or without a `0x` prefix,
     * for which events are queried. This refers to the account that events were emitted
     * to, not the account hosting the move module that emits that event type.
     * @param creationNumber Creation number corresponding to the event type.
     * @returns Array of events assotiated with the given account and creation number.
     */
    getEventsByCreationNumber(address: MaybeHexString, creationNumber: AnyNumber | string, query?: PaginationArgs): Promise<Event[]>;
    /**
     * This API uses the given account `address`, `eventHandle`, and `fieldName`
     * to build a key that can globally identify an event types. It then uses this
     * key to return events emitted to the given account matching that event type.
     * @param address Hex-encoded 32 byte Aptos account, with or without a `0x` prefix,
     * for which events are queried. This refers to the account that events were emitted
     * to, not the account hosting the move module that emits that event type.
     * @param eventHandleStruct String representation of an on-chain Move struct type.
     * (e.g. `0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>`)
     * @param fieldName The field name of the EventHandle in the struct
     * @param query Optional query object
     * @param query.start The start sequence number in the EVENT STREAM, defaulting to the latest event.
     * The events are returned in the reverse order of sequence number
     * @param query.limit The number of events to be returned. The default is 25.
     * @returns Array of events
     */
    getEventsByEventHandle(address: MaybeHexString, eventHandleStruct: MoveStructTag, fieldName: string, query?: PaginationArgs): Promise<Event[]>;
    /**
     * Submits a signed transaction to the transaction endpoint.
     * @param signedTxn A transaction, signed by `signTransaction` method
     * @returns Transaction that is accepted and submitted to mempool
     */
    submitTransaction(signedTxn: Uint8Array): Promise<PendingTransaction>;
    /**
     * Generates and submits a transaction to the transaction simulation
     * endpoint. For this we generate a transaction with a fake signature.
     *
     * @param accountOrPubkey The sender or sender's public key. When private key is available, `AptosAccount` instance
     * can be used to send the transaction for simulation. If private key is not available, sender's public key can be
     * used to send the transaction for simulation.
     * @param rawTransaction The raw transaction to be simulated, likely created
     * by calling the `generateTransaction` function.
     * @param query.estimateGasUnitPrice If set to true, the gas unit price in the
     * transaction will be ignored and the estimated value will be used.
     * @param query.estimateMaxGasAmount If set to true, the max gas value in the
     * transaction will be ignored and the maximum possible gas will be used.
     * @param query.estimatePrioritizedGasUnitPrice If set to true, the transaction will use a higher price than the
     * original estimate.
     * @returns The BCS encoded signed transaction, which you should then provide
     *
     */
    simulateTransaction(accountOrPubkey: AptosAccount | Ed25519PublicKey | MultiEd25519PublicKey, rawTransaction: RawTransaction, query?: {
        estimateGasUnitPrice?: boolean;
        estimateMaxGasAmount?: boolean;
        estimatePrioritizedGasUnitPrice: boolean;
    }): Promise<UserTransaction$1[]>;
    /**
     * Submits a signed transaction to the endpoint that takes BCS payload
     *
     * @param signedTxn A BCS transaction representation
     * @returns Transaction that is accepted and submitted to mempool
     */
    submitSignedBCSTransaction(signedTxn: Uint8Array): Promise<PendingTransaction>;
    /**
     * Submits the BCS serialization of a signed transaction to the simulation endpoint.
     *
     * @param bcsBody The output of `generateBCSSimulation`.
     * @param query?.estimateGasUnitPrice If set to true, the gas unit price in the
     * transaction will be ignored and the estimated value will be used.
     * @param query?.estimateMaxGasAmount If set to true, the max gas value in the
     * transaction will be ignored and the maximum possible gas will be used.
     * @param query?.estimatePrioritizedGasUnitPrice If set to true, the transaction will use a higher price than the
     * original estimate.
     * @returns Simulation result in the form of UserTransaction.
     */
    submitBCSSimulation(bcsBody: Uint8Array, query?: {
        estimateGasUnitPrice?: boolean;
        estimateMaxGasAmount?: boolean;
        estimatePrioritizedGasUnitPrice?: boolean;
    }): Promise<UserTransaction$1[]>;
    /**
     * Queries on-chain transactions. This function will not return pending
     * transactions. For that, use `getTransactionsByHash`.
     *
     * @param query Optional pagination object
     * @param query.start The start transaction version of the page. Default is the latest ledger version
     * @param query.limit The max number of transactions should be returned for the page. Default is 25
     * @returns Array of on-chain transactions
     */
    getTransactions(query?: PaginationArgs): Promise<Transaction$1[]>;
    /**
     * @param txnHash - Transaction hash should be hex-encoded bytes string with 0x prefix.
     * @returns Transaction from mempool (pending) or on-chain (committed) transaction
     */
    getTransactionByHash(txnHash: string): Promise<Transaction$1>;
    /**
     * @param txnVersion - Transaction version is an uint64 number.
     * @returns On-chain transaction. Only on-chain transactions have versions, so this
     * function cannot be used to query pending transactions.
     */
    getTransactionByVersion(txnVersion: AnyNumber): Promise<Transaction$1>;
    /**
     * Defines if specified transaction is currently in pending state
     * @param txnHash A hash of transaction
     *
     * To create a transaction hash:
     *
     * 1. Create hash message bytes: "Aptos::Transaction" bytes + BCS bytes of Transaction.
     * 2. Apply hash algorithm SHA3-256 to the hash message bytes.
     * 3. Hex-encode the hash bytes with 0x prefix.
     *
     * @returns `true` if transaction is in pending state and `false` otherwise
     */
    transactionPending(txnHash: string): Promise<boolean>;
    /**
     * Wait for a transaction to move past pending state.
     *
     * There are 4 possible outcomes:
     * 1. Transaction is processed and successfully committed to the blockchain.
     * 2. Transaction is rejected for some reason, and is therefore not committed
     *    to the blockchain.
     * 3. Transaction is committed but execution failed, meaning no changes were
     *    written to the blockchain state.
     * 4. Transaction is not processed within the specified timeout.
     *
     * In case 1, this function resolves with the transaction response returned
     * by the API.
     *
     * In case 2, the function will throw an ApiError, likely with an HTTP status
     * code indicating some problem with the request (e.g. 400).
     *
     * In case 3, if `checkSuccess` is false (the default), this function returns
     * the transaction response just like in case 1, in which the `success` field
     * will be false. If `checkSuccess` is true, it will instead throw a
     * FailedTransactionError.
     *
     * In case 4, this function throws a WaitForTransactionError.
     *
     * @param txnHash The hash of a transaction previously submitted to the blockchain.
     * @param extraArgs.timeoutSecs Timeout in seconds. Defaults to 20 seconds.
     * @param extraArgs.checkSuccess See above. Defaults to false.
     * @returns See above.
     *
     * @example
     * ```
     * const rawTransaction = await this.generateRawTransaction(sender.address(), payload, extraArgs);
     * const bcsTxn = AptosClient.generateBCSTransaction(sender, rawTransaction);
     * const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
     * const transasction = await this.aptosClient.waitForTransactionWithResult(pendingTransaction.hash);
     * ```
     */
    waitForTransactionWithResult(txnHash: string, extraArgs?: {
        timeoutSecs?: number;
        checkSuccess?: boolean;
    }): Promise<Transaction$1>;
    /**
     * This function works the same as `waitForTransactionWithResult` except it
     * doesn't return the transaction in those cases, it returns nothing. For
     * more information, see the documentation for `waitForTransactionWithResult`.
     */
    waitForTransaction(txnHash: string, extraArgs?: {
        timeoutSecs?: number;
        checkSuccess?: boolean;
    }): Promise<void>;
    /**
     * Queries the latest ledger information
     * @returns Latest ledger information
     * @example Example of returned data
     * ```
     * {
     *   chain_id: 15,
     *   epoch: 6,
     *   ledgerVersion: "2235883",
     *   ledger_timestamp:"1654580922321826"
     * }
     * ```
     */
    getLedgerInfo(): Promise<IndexResponse>;
    /**
     * @returns Current chain id
     */
    getChainId(): Promise<number>;
    /**
     * Gets a table item for a table identified by the handle and the key for the item.
     * Key and value types need to be passed in to help with key serialization and value deserialization.
     * @param handle A pointer to where that table is stored
     * @param data Object, that describes table item
     * @param data.key_type Move type of table key (e.g. `vector<u8>`)
     * @param data.value_type Move type of table value (e.g. `u64`)
     * @param data.key Value of table key
     * @returns Table item value rendered in JSON
     */
    getTableItem(handle: string, data: TableItemRequest, query?: {
        ledgerVersion?: AnyNumber;
    }): Promise<any>;
    /**
     * Generates a raw transaction out of a transaction payload
     * @param accountFrom
     * @param payload
     * @param extraArgs
     * @returns A raw transaction object
     */
    generateRawTransaction(accountFrom: HexString, payload: TransactionPayload, extraArgs?: OptionalTransactionArgs): Promise<RawTransaction>;
    /**
     * Helper for generating, signing, and submitting a transaction.
     *
     * @param sender AptosAccount of transaction sender.
     * @param payload Transaction payload.
     * @param extraArgs Extra args for building the transaction payload.
     * @returns The transaction response from the API.
     */
    generateSignSubmitTransaction(sender: AptosAccount, payload: TransactionPayload, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Helper for signing and submitting a transaction.
     *
     * @param sender AptosAccount of transaction sender.
     * @param transaction A generated Raw transaction payload.
     * @returns The transaction response from the API.
     */
    signAndSubmitTransaction(sender: AptosAccount, transaction: RawTransaction): Promise<string>;
    /**
     * Publishes a move package. `packageMetadata` and `modules` can be generated with command
     * `aptos move compile --save-metadata [ --included-artifacts=<...> ]`.
     * @param sender
     * @param packageMetadata package metadata bytes
     * @param modules bytecodes of modules
     * @param extraArgs
     * @returns Transaction hash
     */
    publishPackage(sender: AptosAccount, packageMetadata: Bytes, modules: Seq<Module>, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Publishes a move packages by creating a resource account.
     * The package cannot be upgraded since it is deployed by resource account
     * `packageMetadata` and `modules` can be generated with command
     * `aptos move compile --save-metadata [ --included-artifacts=<...> ]`.
     * @param sender
     * @param seed seeds for creation of resource address
     * @param packageMetadata package metadata bytes
     * @param modules bytecodes of modules
     * @param extraArgs
     * @returns Transaction hash
     */
    createResourceAccountAndPublishPackage(sender: AptosAccount, seed: Bytes, packageMetadata: Bytes, modules: Seq<Module>, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Helper for generating, submitting, and waiting for a transaction, and then
     * checking whether it was committed successfully. Under the hood this is just
     * `generateSignSubmitTransaction` and then `waitForTransactionWithResult`, see
     * those for information about the return / error semantics of this function.
     */
    generateSignSubmitWaitForTransaction(sender: AptosAccount, payload: TransactionPayload, extraArgs?: OptionalTransactionArgs & {
        checkSuccess?: boolean;
        timeoutSecs?: number;
    }): Promise<Transaction$1>;
    estimateGasPrice(): Promise<GasEstimation>;
    estimateMaxGasAmount(forAccount: MaybeHexString): Promise<Uint64>;
    /**
     * Rotate an account's auth key. After rotation, only the new private key can be used to sign txns for
     * the account.
     * WARNING: You must create a new instance of AptosAccount after using this function.
     * @param forAccount Account of which the auth key will be rotated
     * @param toPrivateKeyBytes New private key
     * @param extraArgs Extra args for building the transaction payload.
     * @returns PendingTransaction
     */
    rotateAuthKeyEd25519(forAccount: AptosAccount, toPrivateKeyBytes: Uint8Array, extraArgs?: OptionalTransactionArgs): Promise<PendingTransaction>;
    /**
     * Lookup the original address by the current derived address
     * @param addressOrAuthKey
     * @returns original address
     */
    lookupOriginalAddress(addressOrAuthKey: MaybeHexString): Promise<HexString>;
    /**
     * Get block by height
     *
     * @param blockHeight Block height to lookup.  Starts at 0
     * @param withTransactions If set to true, include all transactions in the block
     *
     * @returns Block
     */
    getBlockByHeight(blockHeight: number, withTransactions?: boolean): Promise<Block>;
    /**
     * Get block by block transaction version
     *
     * @param version Ledger version to lookup block information for
     * @param withTransactions If set to true, include all transactions in the block
     *
     * @returns Block
     */
    getBlockByVersion(version: number, withTransactions?: boolean): Promise<Block>;
    /**
     * Call for a move view function
     *
     * @param payload Transaction payload
     * @param version (optional) Ledger version to lookup block information for
     *
     * @returns MoveValue[]
     */
    view(payload: ViewRequest, ledger_version?: string): Promise<MoveValue[]>;
    clearCache(tags: string[]): void;
}
/**
 * This error is used by `waitForTransactionWithResult` when waiting for a
 * transaction times out.
 */
declare class WaitForTransactionError extends Error {
    readonly lastSubmittedTransaction: Transaction$1 | undefined;
    constructor(message: string, lastSubmittedTransaction: Transaction$1 | undefined);
}
/**
 * This error is used by `waitForTransactionWithResult` if `checkSuccess` is true.
 * See that function for more information.
 */
declare class FailedTransactionError extends Error {
    readonly transaction: Transaction$1;
    constructor(message: string, transaction: Transaction$1);
}
declare class ApiError extends Error {
    readonly status: number;
    readonly message: string;
    readonly errorCode?: string | undefined;
    readonly vmErrorCode?: string | undefined;
    constructor(status: number, message: string, errorCode?: string | undefined, vmErrorCode?: string | undefined);
}

declare type NetworkWithCustom = Network | "CUSTOM";
/**
 * Builds a Provider class with an aptos client configured to connect to an Aptos node
 * and indexer client configured to connect to Aptos Indexer.
 *
 * It creates AptosClient and IndexerClient instances based on the network or custom endpoints provided.
 *
 * This class holds both AptosClient and IndexerClient classes's methods and properties so we
 * can instantiate the Provider class and use it to query full node and/or Indexer.
 *
 * @example An example of how to use this class
 * ```
 * const provider = new Provider(Network.DEVNET)
 * const account = await provider.getAccount("0x123");
 * const accountNFTs = await provider.getAccountNFTs("0x123");
 * ```
 *
 * @param network enum of type Network - MAINNET | TESTNET | DEVENET or custom endpoints of type CustomEndpoints
 * @param config AptosClient config arg - additional configuration options for the generated Axios client.
 */
declare class Provider {
    aptosClient: AptosClient;
    indexerClient: IndexerClient;
    network: NetworkWithCustom;
    constructor(network: Network | CustomEndpoints, config?: ClientConfig, doNotFixNodeUrl?: boolean);
}
interface Provider extends AptosClient, IndexerClient {
}

declare class PropertyValue {
    type: string;
    value: any;
    constructor(type: string, value: string);
}
declare class PropertyMap {
    data: {
        [key: string]: PropertyValue;
    };
    constructor();
    setProperty(key: string, value: PropertyValue): void;
}
declare function getPropertyValueRaw(values: Array<string>, types: Array<string>): Array<Bytes>;
declare function deserializePropertyMap(rawPropertyMap: any): PropertyMap;
declare function deserializeValueBasedOnTypeTag(tag: TypeTag, val: string): string;

declare class TokenData {
    /** Unique name within this creator's account for this Token's collection */
    collection: string;
    /** Description of Token */
    description: string;
    /** Name of Token */
    name: string;
    /** Optional maximum number of this Token */
    maximum?: number;
    /** Total number of this type of Token */
    supply: number;
    /** URL for additional information / media */
    uri: string;
    /** default properties of token data */
    default_properties: PropertyMap;
    /** mutability config of tokendata fields */
    mutability_config: boolean[];
    constructor(collection: string, description: string, name: string, maximum: number, supply: number, uri: string, default_properties: any, mutability_config: boolean[]);
}
interface TokenDataId {
    /** Token creator address */
    creator: string;
    /** Unique name within this creator's account for this Token's collection */
    collection: string;
    /** Name of Token */
    name: string;
}
interface TokenId {
    token_data_id: TokenDataId;
    /** version number of the property map */
    property_version: string;
}
/** server will return string for u64 */
declare type U64 = string;
declare class Token {
    id: TokenId;
    /** server will return string for u64 */
    amount: U64;
    /** the property map of the token */
    token_properties: PropertyMap;
    constructor(id: TokenId, amount: U64, token_properties: any);
}

type token_types_PropertyMap = PropertyMap;
declare const token_types_PropertyMap: typeof PropertyMap;
type token_types_PropertyValue = PropertyValue;
declare const token_types_PropertyValue: typeof PropertyValue;
type token_types_TokenData = TokenData;
declare const token_types_TokenData: typeof TokenData;
type token_types_TokenDataId = TokenDataId;
type token_types_TokenId = TokenId;
type token_types_Token = Token;
declare const token_types_Token: typeof Token;
declare namespace token_types {
  export {
    token_types_PropertyMap as PropertyMap,
    token_types_PropertyValue as PropertyValue,
    token_types_TokenData as TokenData,
    token_types_TokenDataId as TokenDataId,
    token_types_TokenId as TokenId,
    token_types_Token as Token,
  };
}

/**
 * Class for creating, minting and managing minting NFT collections and tokens
 */
declare class TokenClient {
    aptosClient: AptosClient;
    /**
     * Creates new TokenClient instance
     *
     * @param aptosClient AptosClient instance
     */
    constructor(aptosClient: AptosClient);
    /**
     * Creates a new NFT collection within the specified account
     *
     * @param account AptosAccount where collection will be created
     * @param name Collection name
     * @param description Collection description
     * @param uri URL to additional info about collection
     * @param maxAmount Maximum number of `token_data` allowed within this collection
     * @returns The hash of the transaction submitted to the API
     */
    createCollection(account: AptosAccount, name: string, description: string, uri: string, maxAmount?: AnyNumber, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Creates a new NFT within the specified account
     *
     * @param account AptosAccount where token will be created
     * @param collectionName Name of collection, that token belongs to
     * @param name Token name
     * @param description Token description
     * @param supply Token supply
     * @param uri URL to additional info about token
     * @param max The maxium of tokens can be minted from this token
     * @param royalty_payee_address the address to receive the royalty, the address can be a shared account address.
     * @param royalty_points_denominator the denominator for calculating royalty
     * @param royalty_points_numerator the numerator for calculating royalty
     * @param property_keys the property keys for storing on-chain properties
     * @param property_values the property values to be stored on-chain
     * @param property_types the type of property values
     * @returns The hash of the transaction submitted to the API
     */
    createToken(account: AptosAccount, collectionName: string, name: string, description: string, supply: number, uri: string, max?: AnyNumber, royalty_payee_address?: MaybeHexString, royalty_points_denominator?: number, royalty_points_numerator?: number, property_keys?: Array<string>, property_values?: Array<string>, property_types?: Array<string>, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Creates a new NFT within the specified account
     *
     * @param account AptosAccount where token will be created
     * @param collectionName Name of collection, that token belongs to
     * @param name Token name
     * @param description Token description
     * @param supply Token supply
     * @param uri URL to additional info about token
     * @param max The maxium of tokens can be minted from this token
     * @param royalty_payee_address the address to receive the royalty, the address can be a shared account address.
     * @param royalty_points_denominator the denominator for calculating royalty
     * @param royalty_points_numerator the numerator for calculating royalty
     * @param property_keys the property keys for storing on-chain properties
     * @param property_values the property values to be stored on-chain
     * @param property_types the type of property values
     * @param mutability_config configs which field is mutable
     * @returns The hash of the transaction submitted to the API
     */
    createTokenWithMutabilityConfig(account: AptosAccount, collectionName: string, name: string, description: string, supply: AnyNumber, uri: string, max?: AnyNumber, royalty_payee_address?: MaybeHexString, royalty_points_denominator?: AnyNumber, royalty_points_numerator?: AnyNumber, property_keys?: Array<string>, property_values?: Array<Bytes>, property_types?: Array<string>, mutability_config?: Array<boolean>, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Transfers specified amount of tokens from account to receiver
     *
     * @param account AptosAccount where token from which tokens will be transfered
     * @param receiver  Hex-encoded 32 byte Aptos account address to which tokens will be transfered
     * @param creator Hex-encoded 32 byte Aptos account address to which created tokens
     * @param collectionName Name of collection where token is stored
     * @param name Token name
     * @param amount Amount of tokens which will be transfered
     * @param property_version the version of token PropertyMap with a default value 0.
     * @returns The hash of the transaction submitted to the API
     */
    offerToken(account: AptosAccount, receiver: MaybeHexString, creator: MaybeHexString, collectionName: string, name: string, amount: number, property_version?: number, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Claims a token on specified account
     *
     * @param account AptosAccount which will claim token
     * @param sender Hex-encoded 32 byte Aptos account address which holds a token
     * @param creator Hex-encoded 32 byte Aptos account address which created a token
     * @param collectionName Name of collection where token is stored
     * @param name Token name
     * @param property_version the version of token PropertyMap with a default value 0.
     * @returns The hash of the transaction submitted to the API
     */
    claimToken(account: AptosAccount, sender: MaybeHexString, creator: MaybeHexString, collectionName: string, name: string, property_version?: number, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Removes a token from pending claims list
     *
     * @param account AptosAccount which will remove token from pending list
     * @param receiver Hex-encoded 32 byte Aptos account address which had to claim token
     * @param creator Hex-encoded 32 byte Aptos account address which created a token
     * @param collectionName Name of collection where token is strored
     * @param name Token name
     * @param property_version the version of token PropertyMap with a default value 0.
     * @returns The hash of the transaction submitted to the API
     */
    cancelTokenOffer(account: AptosAccount, receiver: MaybeHexString, creator: MaybeHexString, collectionName: string, name: string, property_version?: number, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Directly transfer the specified amount of tokens from account to receiver
     * using a single multi signature transaction.
     *
     * @param sender AptosAccount where token from which tokens will be transferred
     * @param receiver Hex-encoded 32 byte Aptos account address to which tokens will be transferred
     * @param creator Hex-encoded 32 byte Aptos account address to which created tokens
     * @param collectionName Name of collection where token is stored
     * @param name Token name
     * @param amount Amount of tokens which will be transferred
     * @param property_version the version of token PropertyMap with a default value 0.
     * @returns The hash of the transaction submitted to the API
     */
    directTransferToken(sender: AptosAccount, receiver: AptosAccount, creator: MaybeHexString, collectionName: string, name: string, amount: AnyNumber, propertyVersion?: AnyNumber, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Directly transfer the specified amount of tokens from account to receiver
     * using a single multi signature transaction.
     *
     * @param sender AptosAccount where token from which tokens will be transferred
     * @param receiver Hex-encoded 32 byte Aptos account address to which tokens will be transferred
     * @param creator Hex-encoded 32 byte Aptos account address to which created tokens
     * @param collectionName Name of collection where token is stored
     * @param name Token name
     * @param amount Amount of tokens which will be transferred
     * @param fee_payer AptosAccount which will pay fee for transaction
     * @param property_version the version of token PropertyMap with a default value 0.
     * @returns The hash of the transaction submitted to the API
     */
    directTransferTokenWithFeePayer(sender: AptosAccount, receiver: AptosAccount, creator: MaybeHexString, collectionName: string, name: string, amount: AnyNumber, fee_payer: AptosAccount, propertyVersion?: AnyNumber, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * User opt-in or out direct transfer through a boolean flag
     *
     * @param sender AptosAccount where the token will be transferred
     * @param optIn boolean value indicates user want to opt-in or out of direct transfer
     * @returns The hash of the transaction submitted to the API
     */
    optInTokenTransfer(sender: AptosAccount, optIn: boolean, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Directly transfer token to a receiver. The receiver should have opted in to direct transfer
     *
     * @param sender AptosAccount where the token will be transferred
     * @param creator  address of the token creator
     * @param collectionName Name of collection where token is stored
     * @param name Token name
     * @param property_version the version of token PropertyMap
     * @param amount Amount of tokens which will be transfered
     * @returns The hash of the transaction submitted to the API
     */
    transferWithOptIn(sender: AptosAccount, creator: MaybeHexString, collectionName: string, tokenName: string, propertyVersion: AnyNumber, receiver: MaybeHexString, amount: AnyNumber, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * BurnToken by Creator
     *
     * @param creator creator of the token
     * @param ownerAddress address of the token owner
     * @param collectionName Name of collection where token is stored
     * @param name Token name
     * @param amount Amount of tokens which will be transfered
     * @param property_version the version of token PropertyMap
     * @returns The hash of the transaction submitted to the API
     */
    burnByCreator(creator: AptosAccount, ownerAddress: MaybeHexString, collection: String, name: String, PropertyVersion: AnyNumber, amount: AnyNumber, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * BurnToken by Owner
     *
     * @param owner creator of the token
     * @param creatorAddress address of the token creator
     * @param collectionName Name of collection where token is stored
     * @param name Token name
     * @param amount Amount of tokens which will be transfered
     * @param property_version the version of token PropertyMap
     * @returns The hash of the transaction submitted to the API
     */
    burnByOwner(owner: AptosAccount, creatorAddress: MaybeHexString, collection: String, name: String, PropertyVersion: AnyNumber, amount: AnyNumber, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * creator mutates the properties of the tokens
     *
     * @param account AptosAccount who modifies the token properties
     * @param tokenOwner the address of account owning the token
     * @param creator the creator of the token
     * @param collection_name the name of the token collection
     * @param tokenName the name of created token
     * @param propertyVersion the property_version of the token to be modified
     * @param amount the number of tokens to be modified
     *
     * @returns The hash of the transaction submitted to the API
     */
    mutateTokenProperties(account: AptosAccount, tokenOwner: HexString, creator: HexString, collection_name: string, tokenName: string, propertyVersion: AnyNumber, amount: AnyNumber, keys: Array<string>, values: Array<Bytes>, types: Array<string>, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Queries collection data
     * @param creator Hex-encoded 32 byte Aptos account address which created a collection
     * @param collectionName Collection name
     * @returns Collection data in below format
     * ```
     *  Collection {
     *    // Describes the collection
     *    description: string,
     *    // Unique name within this creators account for this collection
     *    name: string,
     *    // URL for additional information/media
     *    uri: string,
     *    // Total number of distinct Tokens tracked by the collection
     *    count: number,
     *    // Optional maximum number of tokens allowed within this collections
     *    maximum: number
     *  }
     * ```
     */
    getCollectionData(creator: MaybeHexString, collectionName: string): Promise<any>;
    /**
     * Queries token data from collection
     *
     * @param creator Hex-encoded 32 byte Aptos account address which created a token
     * @param collectionName Name of collection, which holds a token
     * @param tokenName Token name
     * @returns Token data in below format
     * ```
     * TokenData {
     *     // Unique name within this creators account for this Token's collection
     *     collection: string;
     *     // Describes this Token
     *     description: string;
     *     // The name of this Token
     *     name: string;
     *     // Optional maximum number of this type of Token.
     *     maximum: number;
     *     // Total number of this type of Token
     *     supply: number;
     *     /// URL for additional information / media
     *     uri: string;
     *   }
     * ```
     */
    getTokenData(creator: MaybeHexString, collectionName: string, tokenName: string): Promise<TokenData>;
    /**
     * Queries token balance for the token creator
     */
    getToken(creator: MaybeHexString, collectionName: string, tokenName: string, property_version?: string): Promise<Token>;
    /**
     * Queries token balance for a token account
     * @param account Hex-encoded 32 byte Aptos account address which created a token
     * @param tokenId token id
     *
     * TODO: Update this:
     * @example
     * ```
     * {
     *   creator: '0x1',
     *   collection: 'Some collection',
     *   name: 'Awesome token'
     * }
     * ```
     * @returns Token object in below format
     * ```
     * Token {
     *   id: TokenId;
     *   value: number;
     * }
     * ```
     */
    getTokenForAccount(account: MaybeHexString, tokenId: TokenId): Promise<Token>;
}

interface CreateCollectionOptions {
    royaltyNumerator?: number;
    royaltyDenominator?: number;
    mutableDescription?: boolean;
    mutableRoyalty?: boolean;
    mutableURI?: boolean;
    mutableTokenDescription?: boolean;
    mutableTokenName?: boolean;
    mutableTokenProperties?: boolean;
    mutableTokenURI?: boolean;
    tokensBurnableByCreator?: boolean;
    tokensFreezableByCreator?: boolean;
}
declare const PropertyTypeMap: {
    BOOLEAN: string;
    U8: string;
    U16: string;
    U32: string;
    U64: string;
    U128: string;
    U256: string;
    ADDRESS: string;
    VECTOR: string;
    STRING: string;
};
declare type PropertyType = keyof typeof PropertyTypeMap;
declare type FungibleTokenParameters = {
    owner: AptosAccount;
    tokenAddress: MaybeHexString;
    recipient: MaybeHexString;
    amount: number | bigint;
    extraArgs?: OptionalTransactionArgs;
};
declare type NonFungibleTokenParameters = {
    owner: AptosAccount;
    tokenAddress: MaybeHexString;
    recipient: MaybeHexString;
    tokenType?: string;
    extraArgs?: OptionalTransactionArgs;
};
/**
 * Class for managing aptos_token
 */
declare class AptosToken {
    readonly provider: Provider;
    private readonly tokenType;
    /**
     * Creates new AptosToken instance
     *
     * @param provider Provider instance
     */
    constructor(provider: Provider);
    private submitTransaction;
    /**
     * Creates a new collection within the specified account
     *
     * @param creator AptosAccount where collection will be created
     * @param description Collection description
     * @param name Collection name
     * @param uri URL to additional info about collection
     * @param options CreateCollectionOptions type. By default all values set to `true` or `0`
     * @returns The hash of the transaction submitted to the API
     */
    createCollection(creator: AptosAccount, description: string, name: string, uri: string, maxSupply?: AnyNumber, options?: CreateCollectionOptions, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Mint a new token within the specified account
     *
     * @param account AptosAccount where token will be created
     * @param collection Name of collection, that token belongs to
     * @param description Token description
     * @param name Token name
     * @param uri URL to additional info about token
     * @param propertyKeys the property keys for storing on-chain properties
     * @param propertyTypes the type of property values
     * @param propertyValues the property values to be stored on-chain
     * @returns The hash of the transaction submitted to the API
     */
    mint(account: AptosAccount, collection: string, description: string, name: string, uri: string, propertyKeys?: Array<string>, propertyTypes?: Array<string>, propertyValues?: Array<string>, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Mint a soul bound token into a recipient's account
     *
     * @param account AptosAccount that mints the token
     * @param collection Name of collection, that token belongs to
     * @param description Token description
     * @param name Token name
     * @param uri URL to additional info about token
     * @param recipient AptosAccount where token will be created
     * @param propertyKeys the property keys for storing on-chain properties
     * @param propertyTypes the type of property values
     * @param propertyValues the property values to be stored on-chain
     * @returns The hash of the transaction submitted to the API
     */
    mintSoulBound(account: AptosAccount, collection: string, description: string, name: string, uri: string, recipient: AptosAccount, propertyKeys?: Array<string>, propertyTypes?: Array<string>, propertyValues?: Array<string>, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Burn a token by its creator
     * @param creator Creator account
     * @param token Token address
     * @returns The hash of the transaction submitted to the API
     */
    burnToken(creator: AptosAccount, token: MaybeHexString, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Freeze token transfer ability
     * @param creator Creator account
     * @param token Token address
     * @returns The hash of the transaction submitted to the API
     */
    freezeTokenTransafer(creator: AptosAccount, token: MaybeHexString, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Unfreeze token transfer ability
     * @param creator Creator account
     * @param token Token address
     * @returns The hash of the transaction submitted to the API
     */
    unfreezeTokenTransafer(creator: AptosAccount, token: MaybeHexString, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Set token description
     * @param creator Creator account
     * @param token Token address
     * @param description Token description
     * @returns The hash of the transaction submitted to the API
     */
    setTokenDescription(creator: AptosAccount, token: MaybeHexString, description: string, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Set token name
     * @param creator Creator account
     * @param token Token address
     * @param name Token name
     * @returns The hash of the transaction submitted to the API
     */
    setTokenName(creator: AptosAccount, token: MaybeHexString, name: string, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Set token URI
     * @param creator Creator account
     * @param token Token address
     * @param uri Token uri
     * @returns The hash of the transaction submitted to the API
     */
    setTokenURI(creator: AptosAccount, token: MaybeHexString, uri: string, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Add token property
     * @param creator Creator account
     * @param token Token address
     * @param key the property key for storing on-chain property
     * @param type the type of property value
     * @param value the property value to be stored on-chain
     * @returns The hash of the transaction submitted to the API
     */
    addTokenProperty(creator: AptosAccount, token: MaybeHexString, propertyKey: string, propertyType: PropertyType, propertyValue: string, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Remove token property
     * @param creator Creator account
     * @param token Token address
     * @param key the property key stored on-chain
     * @returns The hash of the transaction submitted to the API
     */
    removeTokenProperty(creator: AptosAccount, token: MaybeHexString, propertyKey: string, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Update token property
     * @param creator Creator account
     * @param token Token address
     * @param key the property key stored on-chain
     * @param type the property typed stored on-chain
     * @param value the property value to be stored on-chain
     * @returns The hash of the transaction submitted to the API
     */
    updateTokenProperty(creator: AptosAccount, token: MaybeHexString, propertyKey: string, propertyType: PropertyType, propertyValue: string, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    addTypedProperty(creator: AptosAccount, token: MaybeHexString, propertyKey: string, propertyType: PropertyType, propertyValue: string, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    updateTypedProperty(creator: AptosAccount, token: MaybeHexString, propertyKey: string, propertyType: PropertyType, propertyValue: string, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Transfer a non fungible token ownership.
     * We can transfer a token only when the token is not frozen (i.e. owner transfer is not disabled such as for soul bound tokens)
     * @param owner The account of the current token owner
     * @param token Token address
     * @param recipient Recipient address
     * @returns The hash of the transaction submitted to the API
     */
    transferTokenOwnership(owner: AptosAccount, token: MaybeHexString, recipient: MaybeHexString, tokenType?: string, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Transfer a token. This function supports transfer non-fungible token and fungible token.
     *
     * To set the token type, set isFungibleToken param to true or false.
     * If isFungibleToken param is not set, the function would query Indexer
     * for the token data and check whether it is a non-fungible or a fungible token.
     *
     * Note: this function supports only token v2 standard (it does not support the token v1 standard)
     *
     * @param data NonFungibleTokenParameters | FungibleTokenParameters type
     * @param isFungibleToken (optional) The token type, non-fungible or fungible token.
     * @returns The hash of the transaction submitted to the API
     */
    transfer(data: NonFungibleTokenParameters | FungibleTokenParameters, isFungibleToken?: boolean | null): Promise<string>;
}

/**
 * Class for working with the coin module, such as transferring coins and
 * checking balances.
 */
declare class CoinClient {
    aptosClient: AptosClient;
    /**
     * Creates new CoinClient instance
     * @param aptosClient AptosClient instance
     */
    constructor(aptosClient: AptosClient);
    /**
     * Generate, sign, and submit a transaction to the Aptos blockchain API to
     * transfer coins from one account to another. By default it transfers
     * 0x1::aptos_coin::AptosCoin, but you can specify a different coin type
     * with the `coinType` argument.
     *
     * You may set `createReceiverIfMissing` to true if you want to create the
     * receiver account if it does not exist on chain yet. If you do not set
     * this to true, the transaction will fail if the receiver account does not
     * exist on-chain.
     *
     * The TS SDK supports fungible assets operations. If you want to use CoinClient
     * with this feature, set the `coinType` to be the fungible asset metadata address.
     * This option uses the `FungibleAssetClient` class and queries the
     * fungible asset primary store.
     *
     * @param from Account sending the coins
     * @param to Account to receive the coins
     * @param amount Number of coins to transfer
     * @param extraArgs Extra args for building the transaction or configuring how
     * the client should submit and wait for the transaction
     * @returns The hash of the transaction submitted to the API
     */
    transfer(from: AptosAccount, to: AptosAccount | MaybeHexString, amount: number | bigint, extraArgs?: OptionalTransactionArgs & {
        coinType?: string | MaybeHexString;
        createReceiverIfMissing?: boolean;
    }): Promise<string>;
    /**
     * Get the balance of the account. By default it checks the balance of
     * 0x1::aptos_coin::AptosCoin, but you can specify a different coin type.
     *
     * to use a different type, set the `coinType` to be the fungible asset type.
     *
     * The TS SDK supports fungible assets operations. If you want to use CoinClient
     * with this feature, set the `coinType` to be the fungible asset metadata address.
     * This option uses the FungibleAssetClient class and queries the
     * fungible asset primary store.
     *
     * @param account Account that you want to get the balance of.
     * @param extraArgs Extra args for checking the balance.
     * @returns Promise that resolves to the balance as a bigint.
     */
    checkBalance(account: AptosAccount | MaybeHexString, extraArgs?: {
        coinType?: string;
    }): Promise<bigint>;
}

/** Faucet creates and funds accounts. This is a thin wrapper around that. */

/**
 * Class for requsting tokens from faucet
 */
declare class FaucetClient extends AptosClient {
    readonly faucetUrl: string;
    readonly config: ClientConfig | undefined;
    /**
     * Establishes a connection to Aptos node
     * @param nodeUrl A url of the Aptos Node API endpoint
     * @param faucetUrl A faucet url
     * @param config An optional config for inner axios instance
     * Detailed config description: {@link https://github.com/axios/axios#request-config}
     */
    constructor(nodeUrl: string, faucetUrl: string, config?: ClientConfig);
    /**
     * This creates an account if it does not exist and mints the specified amount of
     * coins into that account
     * @param address Hex-encoded 16 bytes Aptos account address wich mints tokens
     * @param amount Amount of tokens to mint
     * @param timeoutSecs
     * @returns Hashes of submitted transactions
     */
    fundAccount(address: MaybeHexString, amount: number, timeoutSecs?: number): Promise<string[]>;
}

declare class AnsClient {
    contractAddress: string;
    provider: Provider;
    /**
     * Creates new AnsClient instance
     * @param provider Provider instance
     * @param contractAddress An optional contract address.
     * If there is no contract address matching to the provided network
     * then the AnsClient class expects a contract address -
     * this is to support both mainnet/testnet networks and local development.
     */
    constructor(provider: Provider, contractAddress?: string);
    /**
     * Returns the primary name for the given account address
     * @param address An account address
     * @returns Account's primary name | null if there is no primary name defined
     */
    getPrimaryNameByAddress(address: string): Promise<string | null>;
    /**
     * Returns the target account address for the given name
     * @param name ANS name
     * @returns Account address | null
     */
    getAddressByName(name: string): Promise<string | null>;
    /**
     * Mint a new Aptos name
     *
     * @param account AptosAccount where collection will be created
     * @param domainName Aptos domain name to mint
     * @param years year duration of the domain name
     * @returns The hash of the pending transaction submitted to the API
     */
    mintAptosName(account: AptosAccount, domainName: string, years?: number, extraArgs?: OptionalTransactionArgs): Promise<HashValue>;
    /**
     * Mint a new Aptos Subdomain
     *
     * @param account AptosAccount the owner of the domain name
     * @param subdomainName subdomain name to mint
     * @param domainName Aptos domain name to mint under
     * @param expirationTimestampSeconds must be set between the domains expiration and the current time
     * @returns The hash of the pending transaction submitted to the API
     */
    mintAptosSubdomain(account: AptosAccount, subdomainName: string, domainName: string, expirationTimestampSeconds?: number, extraArgs?: OptionalTransactionArgs): Promise<HashValue>;
    /**
     * @param account AptosAccount the owner of the domain name
     * @param subdomainName subdomain name to mint
     * @param domainName Aptos domain name to mint
     * @param target the target address for the subdomain
     * @returns The hash of the pending transaction submitted to the API
     */
    setSubdomainAddress(account: AptosAccount, subdomainName: string, domainName: string, target: string, extraArgs?: OptionalTransactionArgs): Promise<HashValue>;
    /**
     * Initialize reverse lookup for contract owner
     *
     * @param owner the `aptos_names` AptosAccount
     * @returns The hash of the pending transaction submitted to the API
     */
    initReverseLookupRegistry(owner: AptosAccount, extraArgs?: OptionalTransactionArgs): Promise<HashValue>;
    /**
     * Returns the AnsRegistry for the given domain name
     * @param domain domain name
     * @example
     * if name is `aptos.apt`
     * domain = aptos
     *
     * @returns AnsRegistry | null
     */
    private getRegistrationForDomainName;
    /**
     * Returns the AnsRegistry for the given subdomain_name
     * @param domain domain name
     * @param subdomain subdomain name
     * @example
     * if name is `dev.aptos.apt`
     * domain = aptos
     * subdomain = dev
     *
     * @returns AnsRegistry | null
     */
    private getRegistrationForSubdomainName;
}

declare class FungibleAssetClient {
    provider: Provider;
    readonly assetType: string;
    /**
     * Creates new FungibleAssetClient instance
     *
     * @param provider Provider instance
     */
    constructor(provider: Provider);
    /**
     *  Transfer `amount` of fungible asset from sender's primary store to recipient's primary store.
     *
     * Use this method to transfer any fungible asset including fungible token.
     *
     * @param sender The sender account
     * @param fungibleAssetMetadataAddress The fungible asset address.
     * For example if you’re transferring USDT this would be the USDT address
     * @param recipient Recipient address
     * @param amount Number of assets to transfer
     * @returns The hash of the transaction submitted to the API
     */
    transfer(sender: AptosAccount, fungibleAssetMetadataAddress: MaybeHexString, recipient: MaybeHexString, amount: number | bigint, extraArgs?: OptionalTransactionArgs): Promise<string>;
    /**
     * Get the balance of a fungible asset from the account's primary fungible store.
     *
     * @param account Account that you want to get the balance of.
     * @param fungibleAssetMetadataAddress The fungible asset address you want to check the balance of
     * @returns Promise that resolves to the balance
     */
    getPrimaryBalance(account: MaybeHexString, fungibleAssetMetadataAddress: MaybeHexString): Promise<bigint>;
    /**
     *
     * Generate a transfer transaction that can be used to sign and submit to transfer an asset amount
     * from the sender primary fungible store to the recipient primary fungible store.
     *
     * This method can be used if you want/need to get the raw transaction so you can
     * first simulate the transaction and then sign and submit it.
     *
     * @param sender The sender account
     * @param fungibleAssetMetadataAddress The fungible asset address.
     * For example if you’re transferring USDT this would be the USDT address
     * @param recipient Recipient address
     * @param amount Number of assets to transfer
     * @returns Raw Transaction
     */
    generateTransfer(sender: AptosAccount, fungibleAssetMetadataAddress: MaybeHexString, recipient: MaybeHexString, amount: number | bigint, extraArgs?: OptionalTransactionArgs): Promise<RawTransaction>;
}

/**
 * A wrapper that handles and manages an account sequence number.
 *
 * Submit up to `maximumInFlight` transactions per account in parallel with a timeout of `sleepTime`
 * If local assumes `maximumInFlight` are in flight, determine the actual committed state from the network
 * If there are less than `maximumInFlight` due to some being committed, adjust the window
 * If `maximumInFlight` are in flight, wait `sleepTime` seconds before re-evaluating
 * If ever waiting more than `maxWaitTime` restart the sequence number to the current on-chain state
 *
 * Assumptions:
 * Accounts are expected to be managed by a single AccountSequenceNumber and not used otherwise.
 * They are initialized to the current on-chain state, so if there are already transactions in
 * flight, they may take some time to reset.
 * Accounts are automatically initialized if not explicitly
 *
 * Notes:
 * This is co-routine safe, that is many async tasks can be reading from this concurrently.
 * The state of an account cannot be used across multiple AccountSequenceNumber services.
 * The synchronize method will create a barrier that prevents additional nextSequenceNumber
 * calls until it is complete.
 * This only manages the distribution of sequence numbers it does not help handle transaction
 * failures.
 * If a transaction fails, you should call synchronize and wait for timeouts.
 */

declare class AccountSequenceNumber {
    readonly provider: Provider;
    readonly account: AptosAccount;
    lastUncommintedNumber: bigint | null;
    currentNumber: bigint | null;
    /**
     * We want to guarantee that we preserve ordering of workers to requests.
     *
     * `lock` is used to try to prevent multiple coroutines from accessing a shared resource at the same time,
     * which can result in race conditions and data inconsistency.
     * This code actually doesn't do it though, since we aren't giving out a slot, it is still somewhat a race condition.
     *
     * The ideal solution is likely that each thread grabs the next number from a incremental integer.
     * When they complete, they increment that number and that entity is able to enter the `lock`.
     * That would guarantee ordering.
     */
    lock: boolean;
    maxWaitTime: number;
    maximumInFlight: number;
    sleepTime: number;
    constructor(provider: Provider, account: AptosAccount, maxWaitTime: number, maximumInFlight: number, sleepTime: number);
    /**
     * Returns the next available sequence number for this account
     *
     * @returns next available sequence number
     */
    nextSequenceNumber(): Promise<bigint | null>;
    /**
     * Initializes this account with the sequence number on chain
     */
    initialize(): Promise<void>;
    /**
     * Updates this account sequence number with the one on-chain
     *
     * @returns on-chain sequence number for this account
     */
    update(): Promise<bigint>;
    /**
     * Synchronizes local sequence number with the seqeunce number on chain for this account.
     *
     * Poll the network until all submitted transactions have either been committed or until
     * the maximum wait time has elapsed
     */
    synchronize(): Promise<void>;
}

/**
 * The AsyncQueue class is an async-aware data structure that provides a queue-like
 * behavior for managing asynchronous tasks or operations.
 * It allows to enqueue items and dequeue them asynchronously.
 * This is not thread-safe but it is async concurrency safe and
 * it does not guarantee ordering for those that call into and await on enqueue.
 */
declare class AsyncQueue<T> {
    readonly queue: T[];
    private resolveMap;
    private counter;
    private cancelled;
    /**
     * The enqueue method adds an item to the queue. If there are pending dequeued promises,
     * in the resolveMap, it resolves the oldest promise with the enqueued item immediately.
     * Otherwise, it adds the item to the queue.
     *
     * @param item T
     */
    enqueue(item: T): void;
    /**
     * The dequeue method returns a promise that resolves to the next item in the queue.
     * If the queue is not empty, it resolves the promise immediately with the next item.
     * Otherwise, it creates a new promise. The promise's resolve function is stored
     * in the resolveMap with a unique counter value as the key.
     * The newly created promise is then returned, and it will be resolved later when an item is enqueued.
     *
     * @returns Promise<T>
     */
    dequeue(): Promise<T>;
    /**
     * The isEmpty method returns whether the queue is empty or not.
     *
     * @returns boolean
     */
    isEmpty(): boolean;
    /**
     * The cancel method cancels all pending promises in the queue.
     * It rejects the promises with a AsyncQueueCancelledError error,
     * ensuring that any awaiting code can handle the cancellation appropriately.
     */
    cancel(): void;
    /**
     * The isCancelled method returns whether the queue is cancelled or not.
     *
     * @returns boolean
     */
    isCancelled(): boolean;
}

/**
 * TransactionWorker provides a simple framework for receiving payloads to be processed.
 *
 * Once one `start()` the process and pushes a new transaction, the worker acquires
 * the current account's next sequence number (by using the AccountSequenceNumber class),
 * generates a signed transaction and pushes an async submission process into the `outstandingTransactions` queue.
 * At the same time, the worker processes transactions by reading the `outstandingTransactions` queue
 * and submits the next transaction to chain, it
 * 1) waits for resolution of the submission process or get pre-execution validation error
 * and 2) waits for the resolution of the execution process or get an execution error.
 * The worker fires events for any submission and/or execution success and/or failure.
 */

declare enum TransactionWorkerEvents {
    TransactionSent = "transactionSent",
    TransactionSendFailed = "transactionsendFailed",
    TransactionExecuted = "transactionExecuted",
    TransactionExecutionFailed = "transactionexecutionFailed"
}
declare class TransactionWorker extends EventEmitter<TransactionWorkerEvents> {
    readonly provider: Provider;
    readonly account: AptosAccount;
    readonly accountSequnceNumber: AccountSequenceNumber;
    readonly taskQueue: AsyncQueue<() => Promise<void>>;
    started: boolean;
    /**
     * transactions payloads waiting to be generated and signed
     *
     * TODO support entry function payload from ABI builder
     */
    transactionsQueue: AsyncQueue<TransactionPayload>;
    /**
     * signed transactions waiting to be submitted
     */
    outstandingTransactions: AsyncQueue<[Promise<PendingTransaction>, bigint]>;
    /**
     * transactions that have been submitted to chain
     */
    sentTransactions: Array<[string, bigint, any]>;
    /**
     * transactions that have been committed to chain
     */
    executedTransactions: Array<[string, bigint, any]>;
    /**
     * Provides a simple framework for receiving payloads to be processed.
     *
     * @param provider - a client provider
     * @param sender - a sender as AptosAccount
     * @param maxWaitTime - the max wait time to wait before resyncing the sequence number
     * to the current on-chain state, default to 30
     * @param maximumInFlight - submit up to `maximumInFlight` transactions per account.
     * Mempool limits the number of transactions per account to 100, hence why we default to 100.
     * @param sleepTime - If `maximumInFlight` are in flight, wait `sleepTime` seconds before re-evaluating, default to 10
     */
    constructor(provider: Provider, account: AptosAccount, maxWaitTime?: number, maximumInFlight?: number, sleepTime?: number);
    /**
     * Gets the current account sequence number,
     * generates the transaction with the account sequence number,
     * adds the transaction to the outstanding transaction queue
     * to be processed later.
     */
    submitNextTransaction(): Promise<void>;
    /**
     * Reads the outstanding transaction queue and submits the transaction to chain.
     *
     * If the transaction has fulfilled, it pushes the transaction to the processed
     * transactions queue and fires a transactionsFulfilled event.
     *
     * If the transaction has failed, it pushes the transaction to the processed
     * transactions queue with the failure reason and fires a transactionsFailed event.
     */
    processTransactions(): Promise<void>;
    /**
     * Once transaction has been sent to chain, we check for its execution status.
     * @param sentTransaction transactions that were sent to chain and are now waiting to be executed
     * @param sequenceNumber the account's sequence number that was sent with the transaction
     */
    checkTransaction(sentTransaction: PromiseFulfilledResult<PendingTransaction>, sequenceNumber: bigint): Promise<void>;
    /**
     * Push transaction to the transactions queue
     * @param payload Transaction payload
     */
    push(payload: TransactionPayload): Promise<void>;
    /**
     * Generates a signed transaction that can be submitted to chain
     * @param account an Aptos account
     * @param sequenceNumber a sequence number the transaction will be generated with
     * @returns
     */
    generateNextTransaction(account: AptosAccount, sequenceNumber: bigint): Promise<Uint8Array | undefined>;
    /**
     * Starts transaction submission and transaction processing.
     */
    run(): Promise<void>;
    /**
     * Starts the transaction management process.
     */
    start(): void;
    /**
     * Stops the the transaction management process.
     */
    stop(): void;
}

declare type Hex = string;
declare type Path = string;
declare type Keys = {
    key: Uint8Array;
    chainCode: Uint8Array;
};
declare const derivePath: (path: Path, seed: Hex, offset?: number) => Keys;

export { AccountSequenceNumber, AnsClient, ApiError, AptosAccount, AptosAccountObject, AptosApiError, AptosClient, AptosRequest, AptosResponse, AptosToken, index$2 as BCS, ClientConfig, CoinClient, CreateCollectionOptions, CustomEndpoints, FailedTransactionError, FaucetClient, FungibleAssetClient, GetRequestOptions, HexString, IndexerClient, MaybeHexString, Network, OptionalTransactionArgs, PostRequestOptions, PropertyType, Provider, RemoteABIBuilderConfig, SigningFn, TokenClient, token_types as TokenTypes, TransactionBuilder, TransactionBuilderABI, TransactionBuilderEd25519, TransactionBuilderMultiEd25519, TransactionBuilderRemoteABI, TransactionWorker, TransactionWorkerEvents, index as TxnBuilderTypes, TypeTagParser, index$1 as Types, WaitForTransactionError, aptosRequest, derivePath, deserializePropertyMap, deserializeValueBasedOnTypeTag, get, getAddressFromAccountOrAddress, getPropertyValueRaw, post };
